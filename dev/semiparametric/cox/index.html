<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cox · SurvivalModels.jl</title><meta name="title" content="Cox · SurvivalModels.jl"/><meta property="og:title" content="Cox · SurvivalModels.jl"/><meta property="twitter:title" content="Cox · SurvivalModels.jl"/><meta name="description" content="Documentation for SurvivalModels.jl."/><meta property="og:description" content="Documentation for SurvivalModels.jl."/><meta property="twitter:description" content="Documentation for SurvivalModels.jl."/><meta property="og:url" content="https://JuliaSurv.github.io/SurvivalModels.jl/semiparametric/cox/"/><meta property="twitter:url" content="https://JuliaSurv.github.io/SurvivalModels.jl/semiparametric/cox/"/><link rel="canonical" href="https://JuliaSurv.github.io/SurvivalModels.jl/semiparametric/cox/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SurvivalModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Nonparametric</span><ul><li><a class="tocitem" href="../../nonparametric/kaplanmeier/">Kaplan-Meier</a></li><li><a class="tocitem" href="../../nonparametric/logranktest/">Log-Rank Test</a></li></ul></li><li><span class="tocitem">Semiparametric</span><ul><li class="is-active"><a class="tocitem" href>Cox</a><ul class="internal"><li><a class="tocitem" href="#Theory"><span>Theory</span></a></li><li><a class="tocitem" href="#Different-versions-of-the-optimisation-routine"><span>Different versions of the optimisation routine</span></a></li><li><a class="tocitem" href="#Comparison-of-the-different-methods-speed"><span>Comparison of the different methods speed</span></a></li></ul></li></ul></li><li><span class="tocitem">Parametric</span></li><li><a class="tocitem" href="../../case_study/">Case Study</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Semiparametric</a></li><li class="is-active"><a href>Cox</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Cox</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSurv/SurvivalModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/main/docs/src/semiparametric/cox.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Cox-models"><a class="docs-heading-anchor" href="#Cox-models">Cox models</a><a id="Cox-models-1"></a><a class="docs-heading-anchor-permalink" href="#Cox-models" title="Permalink"></a></h1><p>one ref: [<a href="../../references/#cox1972regression">1</a>].</p><h2 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h2><p>The Cox Proportional Hazards Model is a semi-parametric model used to analyze time-to-event data. It models the relationship between the survival time of an individual and a set of covariates. It is defined by the <strong>hazard function</strong>:</p><p class="math-container">\[h(t | \mathbf{X}) = h_0(t) \exp(\mathbf{X}^T\mathbf{\beta})\]</p><p>where: <span>$h_0(t)$</span> is the baseline hazard function,  <span>$\mathbf{X}$</span> is the covariate vector,  <span>$\mathbf{\beta}$</span> is the vector of regression coefficients.</p><p>The partial-likelihood function for the Cox model is given by:</p><p class="math-container">\[L(\mathbf{\beta}) = \prod_{j=1}^{k} \frac{\prod_{ \Delta_i=1} \exp(\mathbf{X}_i^T\mathbf{\beta})}{\left( \sum_{l \in R_j} \exp(\mathbf{X}_l^T\mathbf{\beta}) \right)}\]</p><p>Our goal is to maximize the log-partial-likelihood or, equivalently, to minimize its negative, which we define as our loss function:</p><p class="math-container">\[
\text{Loss}(\mathbf{\beta}) = - \log L(\mathbf{\beta}) = - \sum_{j=1}^{k} \left( \sum \mathbf{X}_i^T\mathbf{\beta} - \log \left( \sum_{l \in R_j} \exp(\mathbf{X}_l^T\mathbf{\beta}) \right) \right)
\]</p><p>The loss function is coded as follows: </p><pre><code class="language-julia hljs">function loss(beta, M::Cox)
    η = M.X*beta
    return dot(M.Δ, log.((M.T .&lt;= M.T&#39;) * exp.(η)) .- η)
end</code></pre><p>We differentiate once and obtain the gradient:</p><p class="math-container">\[
\frac{\partial}{\partial \beta_k} \text{Loss}(\mathbf{\beta}) = - \sum_{i=1}^{n} \left( X_{ik} - \frac{\sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j) X_{jk}}{\sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j)} \right)
\]</p><p>And the Hesian matrix: </p><p class="math-container">\[
\frac{\partial^2}{\partial \beta_k \partial \beta_l} \text{Loss}(\mathbf{\beta}) = \sum_{i=1}^{n} \left[ \frac{\sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j) X_{jk}X_{jl}}{\sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j)} - \frac{\left( \sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j) X_{jk} \right) \left( \sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j) X_{jl} \right)}{\left( \sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j) \right)^2} \right]
\]</p><p>The information matrix is defined as the negative of the Hessian matrix of the log-likelihood function, evaluated at the point of the estimated coefficients. </p><p class="math-container">\[
I(\hat{\boldsymbol{\beta}}) = -H(\hat{\boldsymbol{\beta}})
\]</p><p>But, in the earlier formula, <span>$\mathbf{H}_{\text{Loss}}$</span>​ was for Loss(β), which is -log L(β) <span>$\mathbf{H}_{\text{Loss}} = - \mathbf{H}_{\text{log-likelihood}}$</span>. Therefore, the observed Information Matrix is equal to <span>$\mathbf{H}_{\text{Loss}}$</span> itself.</p><p>The variance (and covariance) of our estimators <span>$\hat{\boldsymbol{\beta}}$</span> are obtained by inverting the observed information matrix.</p><p class="math-container">\[\text{Var}(\hat{\boldsymbol{\beta}}) = I(\hat{\boldsymbol{\beta}})^{-1}\]</p><p>This final matrix contains:</p><ul><li>On its diagonal: the variances of each coefficient (<span>$\text{Var}(\hat{\beta}_1)$</span>, <span>$\text{Var}(\hat{\beta}_2)$</span>, ...).</li><li>Off-diagonal: the covariances between pairs of coefficients.</li></ul><p>The standard error for a specific coefficient (<span>$\hat{\beta}_k$</span>) is the square root of its variance.</p><p class="math-container">\[SE(\hat{\beta}_k) = \sqrt{\text{Var}(\hat{\beta}_k)}\]</p><p>To determine if a variable has a statistically significant effect, a Wald test is performed. A z-score is calculated: <span>$z = \frac{\text{Coefficient}}{\text{Erreur Type}} = \frac{\hat{\beta}}{SE(\hat{\beta})}$</span></p><p>This <span>$z$</span>-score is then compared to a normal distribution to obtain a <span>$p$</span>-value. A low <span>$p$</span>-value (typically &lt; 0.05) suggests that the coefficient is significantly different from zero.</p><p>The p-value for each coefficient is calculated by comparing its z-score to a standard normal distribution. This p-value indicates the probability of observing a z-score as extreme as, or more extreme than, the one calculated, assuming the null hypothesis (that the coefficient is zero) is true.</p><p>The standard error allows for the construction of a confidence interval (CI) around the coefficient, which provides a range of plausible values for the true coefficient.</p><p>The general formula for a <span>$(1 - \alpha) \times 100\%$</span> confidence interval is:</p><p class="math-container">\[\text{IC pour } \hat{\beta} = \hat{\beta} \pm z_{\alpha/2} \times SE(\hat{\beta})\]</p><p>Let us see for example the output on the <code>colon</code> dataset: </p><pre><code class="language-julia hljs">using SurvivalModels
using RDatasets

# ovarian = dataset(&quot;survival&quot;, &quot;ovarian&quot;)
# ovarian.FUTime = Float64.(ovarian.FUTime)
# ovarian.FUStat = Bool.(ovarian.FUStat)
# model = fit(Cox, @formula(Surv(FUTime, FUStat) ~ Age + ECOG_PS), ovarian)

colon = dataset(&quot;survival&quot;, &quot;colon&quot;)
colon.Time = Float64.(colon.Time)
colon.Status = Bool.(colon.Status)
model_colon = fit(Cox, @formula(Surv(Time, Status) ~ Age + Rx), colon)</code></pre><div><div style = "float: left;"><span>3×5 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Predictor</th><th style = "text-align: left;">β</th><th style = "text-align: left;">SE</th><th style = "text-align: left;">P_Value</th><th style = "text-align: left;">z</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "String" style = "text-align: left;">String</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">Age</td><td style = "text-align: right;">-0.00205614</td><td style = "text-align: right;">0.00280669</td><td style = "text-align: right;">0.463812</td><td style = "text-align: right;">-0.732585</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: left;">Rx: Lev</td><td style = "text-align: right;">-0.0200488</td><td style = "text-align: right;">0.0768372</td><td style = "text-align: right;">0.79415</td><td style = "text-align: right;">-0.260925</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: left;">Rx: Lev+5FU</td><td style = "text-align: right;">-0.439289</td><td style = "text-align: right;">0.0839364</td><td style = "text-align: right;">1.66245e-7</td><td style = "text-align: right;">-5.23359</td></tr></tbody></table></div><p>The outputed datafrae contains collumns with respectively the name of the predictor, the obtained coefficients, its standard error, the associated p-value and the test statistic z as just described. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SurvivalModels.Cox" href="#SurvivalModels.Cox"><code>SurvivalModels.Cox</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StatsBase.fit(Cox, @formula(Surv(T,Δ)~predictors), dataset)

arguments: 
- T: The Cox model type to fit (CoxV3)
- formula: A StatsModels.FormulaTerm specifying the survival model
- df: A DataFrame containing the variables specified in the formula

returns: 
- predictor: A Vector{String} containing the names of the predictor variables included in the model
- beta: A Vector{Float64} containing the estimated regression coefficients (β​) for each predictor
- se: A Vector{Float64} containing the standard errors of the estimated regression coefficients
- loglikelihood: A Vector{Float64} containing the log-likelihood of the fitted model. This value is repeated for each predictor row 

- coef: A vector of the estimated coefficients
- formula: The applied formula</code></pre><p>Example: ovarian = dataset(&quot;survival&quot;, &quot;ovarian&quot;) ovarian.FUTime = Float64.(ovarian.FUTime) (Time column needs to be Float64 type) ovarian.FUStat = Bool.(ovarian.FUStat) (Status column needs to be Bool type) model = fit(Cox, @formula(Surv(FUTime, FUStat) ~ Age + ECOG_PS), ovarian)</p><p>Types: </p><ul><li>Cox : the base abstract type</li><li>CoxGrad&lt;:Cox : abstract type for Cox models that are solved using gradient-based optimization</li><li>CoxLLH&lt;:CoxGrad : abstract type for Cox models that are solved by optimizing the log-likelihood</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/25a49bc310723e72aa0b63cf481e65281f04ec3f/src/Semiparametric/Cox.jl#L1-L30">source</a></section></article><h2 id="Different-versions-of-the-optimisation-routine"><a class="docs-heading-anchor" href="#Different-versions-of-the-optimisation-routine">Different versions of the optimisation routine</a><a id="Different-versions-of-the-optimisation-routine-1"></a><a class="docs-heading-anchor-permalink" href="#Different-versions-of-the-optimisation-routine" title="Permalink"></a></h2><p>To implement the Cox proportional hazards model, different versions were coded, using different methods. The final goal is to compare these versions and choose the most efficient one: the fastest and the closest to the true values of the coefficients. </p><h3 id="V0"><a class="docs-heading-anchor" href="#V0">V0</a><a id="V0-1"></a><a class="docs-heading-anchor-permalink" href="#V0" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SurvivalModels.CoxV0" href="#SurvivalModels.CoxV0"><code>SurvivalModels.CoxV0</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoxVO(T, Δ, X)
fit(CoxV0, @formula(Surv(T,Δ)~X), data = ...)</code></pre><p>An implementation of the Cox proportional hazards model that minimizes the negative partial log-likelihood function (<code>cox_nllh</code>). This version uses the Nelder-Mead method, a derivative-free optimization algorithm. </p><p>Fields:      - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features     - T::Vector{Float64}: The observed times, sorted in ascending order      - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/25a49bc310723e72aa0b63cf481e65281f04ec3f/src/Semiparametric/Cox/v0.jl#L1-L12">source</a></section></article><h3 id="V1:-Implementation-using-the-&#39;Optimization.jl&#39;-Julia-package"><a class="docs-heading-anchor" href="#V1:-Implementation-using-the-&#39;Optimization.jl&#39;-Julia-package">V1: Implementation using the &#39;Optimization.jl&#39; Julia package</a><a id="V1:-Implementation-using-the-&#39;Optimization.jl&#39;-Julia-package-1"></a><a class="docs-heading-anchor-permalink" href="#V1:-Implementation-using-the-&#39;Optimization.jl&#39;-Julia-package" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SurvivalModels.CoxV1" href="#SurvivalModels.CoxV1"><code>SurvivalModels.CoxV1</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoxV1(T, Δ, X)
fit(CoxV1, @formula(Surv(T,Δ)~X), data = ...)</code></pre><p>The first implementation of the Cox proportional hazards model uses optimization libraries (Optimization.jl, Optim.jl) for coefficient estimation. It uses the BFGS algorithm to minimize the negative partial log-likelihood. </p><p>Fields:      - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features.     - T::Vector{Float64}: The observed times, sorted in ascending order     - Δ::Vector{Int64}: The event indicator vector (true for event, false for censoring)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/25a49bc310723e72aa0b63cf481e65281f04ec3f/src/Semiparametric/Cox/v1.jl#L1-L12">source</a></section></article><h3 id="V2:-Implementation-using-the-gradient-and-the-Hessian-matrix"><a class="docs-heading-anchor" href="#V2:-Implementation-using-the-gradient-and-the-Hessian-matrix">V2: Implementation using the gradient and the Hessian matrix</a><a id="V2:-Implementation-using-the-gradient-and-the-Hessian-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#V2:-Implementation-using-the-gradient-and-the-Hessian-matrix" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SurvivalModels.CoxV2" href="#SurvivalModels.CoxV2"><code>SurvivalModels.CoxV2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoxV2(T, Δ, X)
fit(CoxV2, @formula(Surv(T,Δ)~X), data = ...)</code></pre><p>The second implementation of the Cox proportional hazards model uses a Newton-Raphson-like iterative update that directly calculates and utilizes the gradient and Hessian matrix. This version is updating coefficients via the update! function.</p><p>Fields:     - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features     - T::Vector{Float64}: The observed times, sorted in ascending order     - Δ::Vector{Int64}: The event indicator vector (true for event, false for censoring)     - R::BitMatrix: A boolean risk matrix, where &#39;R[i,j]&#39; is &#39;true&#39; if individual &#39;j&#39; is at risk at time &#39;T[i]&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/25a49bc310723e72aa0b63cf481e65281f04ec3f/src/Semiparametric/Cox/v2.jl#L1-L12">source</a></section></article><h3 id="V3:-Improved-version-of-V2-(much-faster)-because-non-allocative."><a class="docs-heading-anchor" href="#V3:-Improved-version-of-V2-(much-faster)-because-non-allocative.">V3: Improved version of V2 (much faster) because non-allocative.</a><a id="V3:-Improved-version-of-V2-(much-faster)-because-non-allocative.-1"></a><a class="docs-heading-anchor-permalink" href="#V3:-Improved-version-of-V2-(much-faster)-because-non-allocative." title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SurvivalModels.CoxV3" href="#SurvivalModels.CoxV3"><code>SurvivalModels.CoxV3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoxV3(T, Δ, X)
fit(CoxV3, @formula(Surv(T,Δ)~X), data = ...)
fit(Cox, @formula(Surv(T,Δ)~X), data = ...)</code></pre><p>The third implementation of the Cox proportional hazards model represents a highly optimized and significantly faster iteration compared to previous implementation, CoxV2.</p><p>This is the default implementation called when you ask for a Cox model. </p><p>Fields:     - Xᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)     - sX::Vector{Float64}: Sum of X&#39; multiplied by Δ     - T::Vector{Float64}: The observed times sorted in descending order     - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)     - loss::Vector{Float64}: Stores the current negative partial log-likelihood value     - G::Vector{Float64}: Stores the gradient vector       - H::Matrix{Float64}: Stores the Hessian matrix      - S₁::Vector{Float64}: Sum of rⱼxₖⱼ     - S₂::Matrix{Float64}: Sum of rⱼxₖⱼ * xⱼ     - μ::Vector{Float64}: Updates the gradient and Hessian     - η::Vector{Float64}: ηi = Xiβ     - r::Vector{Float64}: ri = exp(ηi)     - R::Vector{UnitRange{Int64}}: A vector of the risk ranges for each output time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/25a49bc310723e72aa0b63cf481e65281f04ec3f/src/Semiparametric/Cox/v3.jl#L1-L24">source</a></section></article><h3 id="V4:-Majoration-of-the-Hessian-matrix-by-a-universal-bound."><a class="docs-heading-anchor" href="#V4:-Majoration-of-the-Hessian-matrix-by-a-universal-bound.">V4: Majoration of the Hessian matrix by a universal bound.</a><a id="V4:-Majoration-of-the-Hessian-matrix-by-a-universal-bound.-1"></a><a class="docs-heading-anchor-permalink" href="#V4:-Majoration-of-the-Hessian-matrix-by-a-universal-bound." title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SurvivalModels.CoxV4" href="#SurvivalModels.CoxV4"><code>SurvivalModels.CoxV4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoxV4(T, Δ, X)
fit(CoxV4, @formula(Surv(T,Δ)~X), data = ...)</code></pre><p>The fourth implementation of the Cox proportional hazards model uses Hessian approximation based on a pre-calculated estimation. This version was created for when it might be difficult to work with full Hessian , offering faster iterations by using a Hessian approximation.</p><p>Fields:     - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features     - T::Vector{Float64}: The observed times sorted in ascending order     - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)     - sX::Vector{Float64}: Sum of X&#39; multiplied by Δ     - G::Vector{Float64}: Stores the gradient vector     - η::Vector{Float64}: ηi = Xiβ     - A::Vector{Float64}: Ai = exp(ηi)     - B::Vector{Float64}: Stores the majoration elements of the Hessian matrix     - C::Vector{Float64}: Used in the mkA! function     - K::Vector{Int64}: Number of events at each unique observed event time     - loss::Vector{Float64}: Stores the current negative partial log-likelihood value, used in CoxLLH getβ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/25a49bc310723e72aa0b63cf481e65281f04ec3f/src/Semiparametric/Cox/v4.jl#L1-L19">source</a></section></article><h3 id="V5"><a class="docs-heading-anchor" href="#V5">V5</a><a id="V5-1"></a><a class="docs-heading-anchor-permalink" href="#V5" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SurvivalModels.CoxV5" href="#SurvivalModels.CoxV5"><code>SurvivalModels.CoxV5</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoxV5(T, Δ, X)
fit(CoxV5, @formula(Surv(T,Δ)~X), data = ...)</code></pre><p>The fifth implementation of the Cox proportional hazards model uses a pre-calculated Hessian approximation for faster iterations, like CoxV4. Its approach is similar to CoxV3.</p><p>Fields:     - Xᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)     - sX::Vector{Float64}: Sum of X&#39; multiplied by Δ     - T::Vector{Float64}: The observed times sorted in descending order     - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)     - loss::Vector{Float64}: Stores the current negative partial log-likelihood value     - G::Vector{Float64}: Stores the gradient vector.     - S₁::Vector{Float64}:  Sum of rⱼxₖⱼ     - μ::Vector{Float64}: Currently unused in <code>update!</code> function     - η::Vector{Float64}: ηi = Xiβ     - r::Vector{Float64}: ri = exp(ηi)     - R::Vector{UnitRange{Int64}}:     - B::Vector{Float64}: Stores the majoration elements of the Hessian matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/25a49bc310723e72aa0b63cf481e65281f04ec3f/src/Semiparametric/Cox/v5.jl#L1-L20">source</a></section></article><h2 id="Comparison-of-the-different-methods-speed"><a class="docs-heading-anchor" href="#Comparison-of-the-different-methods-speed">Comparison of the different methods speed</a><a id="Comparison-of-the-different-methods-speed-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-of-the-different-methods-speed" title="Permalink"></a></h2><p>We propose to compare the different methods on simulated data, with varying number of lines and columns, to verify empirically the theoretical complexity of the different methods.  We will then compare the results with Julia&#39;s and R&#39;s existing Cox implementation.</p><pre><code class="language-julia hljs">using SurvivalModels, Plots, Random, Distributions, StatsBase, LinearAlgebra, DataFrames, RCall, Survival

using SurvivalModels: getβ, CoxV0, CoxV1, CoxV2, CoxV3, CoxV4, CoxV5</code></pre><pre><code class="language-julia hljs">struct CoxVJ
    T::Vector{Float64}
    Δ::Vector{Bool}
    X::Matrix{Float64}
    function CoxVJ(T,Δ,X)
        new(T,Bool.(Δ),X)
    end
end

function SurvivalModels.getβ(M::CoxVJ)
    return fit(Survival.CoxModel, M.X, Survival.EventTime.(M.T,M.Δ)).β
end</code></pre><pre><code class="language-julia hljs">R&quot;&quot;&quot;
library(survival)
&quot;&quot;&quot;

struct CoxVR
    df::DataFrame
    function CoxVR(T,Δ,X)
        df = DataFrame(X,:auto)
        df.status = Δ
        df.time = T
        new(df)
    end
end

function SurvivalModels.getβ(M::CoxVR)
    df = M.df
    @rput df
    R&quot;&quot;&quot;
    beta  &lt;- coxph(Surv(time,status)~., data = df, ties=&quot;breslow&quot;)$coefficients
    &quot;&quot;&quot;
    @rget beta
    return beta
end</code></pre><pre><code class="language-julia hljs"># Creating a dictionary for all the models:
# Label =&gt; (constructor, plotting color)

const design = Dict(
&quot;V0&quot;=&gt; (CoxV0, :blue),
&quot;V1&quot;=&gt; (CoxV1, :orange),
&quot;V2&quot;=&gt; (CoxV2, :brown),
&quot;V3&quot;=&gt; (CoxV3, :purple),
&quot;V4&quot;=&gt; (CoxV4, :green),
&quot;V5&quot;=&gt; (CoxV5, :yellow),
&quot;VR&quot;=&gt; (CoxVR, :red),
&quot;VJ&quot;=&gt; (CoxVJ, :black)
);

# Function to simulate data for different rows and column numbers (n max = 2000 et m max = 20):
function simulate_survival_data(n, m; censor_rate = 0.2, β=randn(m))
    Random.seed!(42)
    X = hcat(
        [randn(n)       for _ in 1:cld(m,3)]..., # about 1/3
        [rand(n)        for _ in 1:cld(m,3)]..., # about 1/3
        [exp.(randn(n)) for _ in 1:(m-2cld(m,3))]... # the rest.
    )
    η = X * β
    λ₀ = 1
    U = rand(n)
    O = -log.(U) ./ (λ₀ .* exp.(η))
    lc = quantile(O, 1 - censor_rate)
    C = rand(Exponential(lc), n)
    T = min.(O, C)
    Δ = Bool.(T .&lt;= C)
    return (T, Δ, X)
end

# Run the models and get the running time, the β coefficients and the difference between the true β and the obtained ones:
function run_models()
    Ns = (500, 1000, 2000)
    Ms = (10, 20)
    true_betas = randn(maximum(Ms))
    df = []
    for n in Ns, m in Ms
        if (n == 2000) | (m == 20) # Only if they end up in the graphs.
            data = simulate_survival_data(n,m, β = true_betas[1:m])
            for (name, (constructor, _)) in design
                display((n,m,name))
                model = constructor(data...)
                beta = getβ(model)
                time = @elapsed getβ(model)
                push!(df, (
                    n = n,
                    m = m,
                    name = name,
                    time = time,
                    beta = beta,
                    diff_to_truth = sqrt(sum((beta .- true_betas[1:m]).^2)/sum(true_betas[1:m].^2)),
                ))
            end
        end
    end
    df = DataFrame(df)
    sort!(df, :name)
    return df
end

# Plot the results, starting with the time:
function timing_graph(df)
    group1 = groupby(filter(r -&gt; r.m==20, df), :name)
    p1 = plot(; xlabel = &quot;Number of observations (n)&quot;,
        ylabel = &quot;Time (in seconds)&quot;,
        yscale= :log10,
        xscale= :log10,
        title = &quot;For m=20 covs., varying n&quot;,
        legend = :bottomright,
        lw = 1);
    for g in group1
        plot!(p1, g.n, g.time, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)
    end
    group2 = groupby(filter(r -&gt; r.n==2000, df), :name)
        p2 = plot(; xlabel = &quot;Number of covariates (m)&quot;,
            ylabel = &quot;Temps (ms)&quot;,
            yscale= :log10,
            xscale= :log10,
            title = &quot;For n=2000 obs., varying m&quot;,
            legend = :bottomright,
            lw = 1);
        for g in group2
            plot!(p2, g.m, g.time, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)
        end
        p = plot(p1,p2, size=(1200,600), plot_title = &quot;Runtime (logscale) of the various implementations&quot;)
        return p
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">timing_graph (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">x=1
# df = run_models()
# timing_graph(df)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>comments on the graph. </p><p>A zoom on our implementation vs Survival.jl vs R::survival: </p><pre><code class="language-julia hljs">x=1
# timing_graph(filter(r -&gt; r.name ∈ (&quot;V3&quot;, &quot;VJ&quot;, &quot;VR&quot;), df))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>So we are about x10 faster than the reference implmentation of R (and than the previous Julia attemps) on this example. </p><pre><code class="language-julia hljs">function beta_correctness_graphs(df; ref=&quot;VJ&quot;)

    reflines = filter(r -&gt; r.name == ref, df)
    rename!(reflines, :beta =&gt; :refbeta)
    select!(reflines, Not([:name, :time, :diff_to_truth]))
    otherlines = filter(r -&gt; r.name != ref, df)
    rez = leftjoin(otherlines, reflines, on=[:n,:m])
    percent(x,y) = sqrt(sum((x .- y).^2)/sum(y .^2))
    rez.error = percent.(rez.beta, rez.refbeta)
    select!(rez, [:n,:m,:name,:error])
    rez = filter!(r -&gt; !isnan(r.error), rez)

    group1 = groupby(filter(r -&gt; r.m==20, rez), :name)
    p1 = plot(; xlabel = &quot;Number of observations (n)&quot;,
                ylabel = &quot;L2dist to $ref&#39;s β&quot;,
                yscale=:log10,
                xscale= :log10,
                title = &quot;m=20, varying n&quot;,
                legend = :bottomright,
                lw = 1);
    for g in group1
        plot!(p1, g.n, g.error, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)
    end

    group2 = groupby(filter(r -&gt; r.n==2000, rez), :name)
    p2 = plot(; xlabel = &quot;Nomber of covariates (m)&quot;,
                ylabel = &quot;L2Dist to $ref&#39;s β&quot;,
                yscale=:log10,
                xscale= :log10,
                title = &quot;n=2000, varying m&quot;,
                legend = :bottomright,
                lw = 1);
    for g in group2
        plot!(p2, g.m, g.error, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)
    end
    p = plot(p1,p2, size=(1200,600), plot_title=&quot;β-correctness w.r.t. $ref&#39;s version.&quot;)
    return p
end

# beta_correctness_graphs(df)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">beta_correctness_graphs (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">function beta_wrt_truth(df)
    group1 = groupby(filter(r -&gt; r.m==20, df), :name)
    p1 = plot(; xlabel = &quot;Number of observations (n)&quot;,
                ylabel = &quot;L2dist to the truth&quot;,
                yscale=:log10,
                xscale= :log10,
                title = &quot;m=20, varying n&quot;,
                legend = :bottomright,
                lw = 1);
    for g in group1
        plot!(p1, g.n, g.diff_to_truth, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)
    end

    group2 = groupby(filter(r -&gt; r.n==2000, df), :name)
    p2 = plot(; xlabel = &quot;Nomber of covariates (m)&quot;,
                ylabel = &quot;L2Dist to the truth&quot;,
                yscale=:log10,
                xscale= :log10,
                title = &quot;n=2000, varying m&quot;,
                legend = :bottomright,
                lw = 1);
    for g in group2
        plot!(p2, g.m, g.diff_to_truth, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)
    end
    p = plot(p1,p2, size=(1200,600), plot_title=&quot;β-correctness w.r.t. the truth.&quot;)
    return p
end

# beta_wrt_truth(df)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">beta_wrt_truth (generic function with 1 method)</code></pre><div class="citation noncanonical"><dl><dt>[1]</dt><dd><div>D. R. Cox. <em>Regression models and life-tables</em>. Journal of the Royal Statistical Society: Series B (Methodological) <strong>34</strong>, 187–202 (1972).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../nonparametric/logranktest/">« Log-Rank Test</a><a class="docs-footer-nextpage" href="../../case_study/">Case Study »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 15 July 2025 14:04">Tuesday 15 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
