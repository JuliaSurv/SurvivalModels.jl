<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cox · SurvivalModels.jl</title><meta name="title" content="Cox · SurvivalModels.jl"/><meta property="og:title" content="Cox · SurvivalModels.jl"/><meta property="twitter:title" content="Cox · SurvivalModels.jl"/><meta name="description" content="Documentation for SurvivalModels.jl."/><meta property="og:description" content="Documentation for SurvivalModels.jl."/><meta property="twitter:description" content="Documentation for SurvivalModels.jl."/><meta property="og:url" content="https://JuliaSurv.github.io/SurvivalModels.jl/semiparametric/cox/"/><meta property="twitter:url" content="https://JuliaSurv.github.io/SurvivalModels.jl/semiparametric/cox/"/><link rel="canonical" href="https://JuliaSurv.github.io/SurvivalModels.jl/semiparametric/cox/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SurvivalModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Nonparametric</span><ul><li><a class="tocitem" href="../../nonparametric/kaplanmeier/">Kaplan-Meier</a></li><li><a class="tocitem" href="../../nonparametric/logranktest/">Log-Rank Test</a></li></ul></li><li><span class="tocitem">Semiparametric</span><ul><li class="is-active"><a class="tocitem" href>Cox</a><ul class="internal"><li><a class="tocitem" href="#The-Cox-Proportional-Hazards-Model:-Theory"><span>The Cox Proportional Hazards Model: Theory</span></a></li><li><a class="tocitem" href="#Different-versions-of-the-optimisation-routine"><span>Different versions of the optimisation routine</span></a></li><li><a class="tocitem" href="#Comparison-of-the-different-methods-speed"><span>Comparison of the different methods speed</span></a></li><li><a class="tocitem" href="#Model-Evaluation:-Harrell&#39;s-Concordance-Index-(C-index)"><span>Model Evaluation: Harrell&#39;s Concordance Index (C-index)</span></a></li></ul></li></ul></li><li><span class="tocitem">Parametric</span><ul><li><a class="tocitem" href="../../parametric/generalhazard/">General Hazard</a></li></ul></li><li><a class="tocitem" href="../../case_study/">Case Study</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Semiparametric</a></li><li class="is-active"><a href>Cox</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Cox</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSurv/SurvivalModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/main/docs/src/semiparametric/cox.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Cox-models"><a class="docs-heading-anchor" href="#Cox-models">Cox models</a><a id="Cox-models-1"></a><a class="docs-heading-anchor-permalink" href="#Cox-models" title="Permalink"></a></h1><h2 id="The-Cox-Proportional-Hazards-Model:-Theory"><a class="docs-heading-anchor" href="#The-Cox-Proportional-Hazards-Model:-Theory">The Cox Proportional Hazards Model: Theory</a><a id="The-Cox-Proportional-Hazards-Model:-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#The-Cox-Proportional-Hazards-Model:-Theory" title="Permalink"></a></h2><p>The Cox Proportional Hazards Model [<a href="../../references/#cox1972regression">4</a>] is a semi-parametric model used to analyze time-to-event data. It models the relationship between the survival time of an individual and a set of explanatory variables (covariates). </p><h3 id="1.-The-Hazard-Function"><a class="docs-heading-anchor" href="#1.-The-Hazard-Function">1. The Hazard Function</a><a id="1.-The-Hazard-Function-1"></a><a class="docs-heading-anchor-permalink" href="#1.-The-Hazard-Function" title="Permalink"></a></h3><p>The model is defined by the <strong>hazard function</strong>, which describes the risk of an event occuring at time <span>$t$</span>, given that the event has not occured before the time <span>$t$</span>. The hazard function is given by:</p><p class="math-container">\[h(t | \mathbf{X}) = h_0(t) \exp(\mathbf{X}^T\mathbf{\beta})\]</p><p>where:</p><ul><li><span>$h_0(t)$</span> is the <strong>baseline hazard function</strong>. This is an unspecified, non-negative function of time that represents the hazard for an individual with all covariates equal to zero. It captures the underlying risk profile common to all individuals.</li><li><span>$\mathbf{X}$</span> is the <strong>covariate vector</strong> for an individual. These are the independent variables (e.g., age, treatment, gender) that influence the event time.</li><li><span>$\mathbf{\beta}$</span> is the <strong>vector of regression coefficients</strong>.</li></ul><p>The term <span>$exp(\mathbf{X}^T\mathbf{\beta})$</span> is often called the hazard ratio.</p><h3 id="2.-The-Survival-Function"><a class="docs-heading-anchor" href="#2.-The-Survival-Function">2. The Survival Function</a><a id="2.-The-Survival-Function-1"></a><a class="docs-heading-anchor-permalink" href="#2.-The-Survival-Function" title="Permalink"></a></h3><p>The <strong>survival function</strong>, <span>$S(t)$</span>, which represents the probability that an individual survives beyond time <span>$t$</span>.</p><p class="math-container">\[S(t | \mathbf{X}) = \exp\left(-\int_0^t h(u | \mathbf{X}) du\right)\]</p><p>After substituting the Cox hazard function:</p><p class="math-container">\[S(t | \mathbf{X}) = \exp\left(-\exp(\mathbf{X}^\top \boldsymbol{\beta}) \int_0^t h_0(u) du\right)\]</p><p>with <span>$H_0(t) = \int_0^t h_0(u) du$</span></p><p>Finally, </p><p class="math-container">\[S(t | \mathbf{X}) = \exp\left(-\exp(\mathbf{X}^\top \boldsymbol{\beta}) H_0(t)\right)\]</p><h3 id="3.-The-Full-Likelihood-Function"><a class="docs-heading-anchor" href="#3.-The-Full-Likelihood-Function">3. The Full Likelihood Function</a><a id="3.-The-Full-Likelihood-Function-1"></a><a class="docs-heading-anchor-permalink" href="#3.-The-Full-Likelihood-Function" title="Permalink"></a></h3><p>The full likelihood function includes the baseline hazard:</p><p class="math-container">\[L(\boldsymbol{\beta}, h_0(\cdot)) = \prod_{i=1}^n \left( h(t_i | \mathbf{X}_i) \right)^{\Delta_i} S(t_i | \mathbf{X}_i)\]</p><p>with:</p><ul><li><span>$h(t_i | \mathbf{X}_i)$</span> for the individuals at risk of the event at time <span>$t_i(\Delta_i​=1)$</span></li><li><span>$S(t_i | \mathbf{X}_i)$</span> for the individuals censored at time <span>$t_i​(\Delta_i​=0)$</span></li></ul><p>And if we substitute the hazard and survival function:</p><p class="math-container">\[L(\boldsymbol{\beta}, h_0(\cdot)) = \prod_{i=1}^n \left( h_0(t_i) \exp(\mathbf{X}_i^\top \boldsymbol{\beta}) \right)^{\Delta_i} \exp\left(-\exp(\mathbf{X}_i^\top \boldsymbol{\beta}) H_0(t_i)\right)\]</p><h3 id="4.-The-Partial-Likelihood-Function"><a class="docs-heading-anchor" href="#4.-The-Partial-Likelihood-Function">4. The Partial-Likelihood Function</a><a id="4.-The-Partial-Likelihood-Function-1"></a><a class="docs-heading-anchor-permalink" href="#4.-The-Partial-Likelihood-Function" title="Permalink"></a></h3><p>Since the baseline hazard function <span>$h_0(t)$</span> is unspecified, a standard likelihood function cannot be formed directly. Instead, Cox introduced the concept of a partial likelihood. This approach focuses on the order of events rather than their exact timings, factoring out the unknown <span>$h_0(t)$</span>.</p><p>For each distinct observed event time <span>$t_(j)$</span>, we consider the set of individuals who are &quot;at risk&quot; of experiencing the event just before <span>$t_(j)$</span>. This is called the risk set, <span>$R(t_(j))$</span>. The partial likelihood is constructed by considering the probability that the specific individual(s) who experienced the event at <span>$t_(j)$</span> were the ones to fail, given that some event occurred among the individuals in <span>$R(t_(j))$</span>. We can write this as follows: <span>$P(\text{Individual } i \text{ fails at } t \mid \text{An event occurs in } R(t) \text{ at } t)$</span>. Using the defintion of the conditional probability:</p><p class="math-container">\[P(\text{Individual } i \text{ fails at } t \mid \text{An event occurs in } R(t) \text{ at } t) = \frac{P(\text{Individual } i \text{ fails at } t)}{\sum_{l \in R(t)} P(\text{Individual } l \text{ fails at } t)}\]</p><p>By substituting the hazard function and canceling out <span>$h_0(t)$</span>and <span>$dt$</span>:</p><p class="math-container">\[\frac{h_i(t)dt}{\sum_{l \in R(t)} h_l(t)dt} = \frac{h_0(t)\exp(\mathbf{X}_i^T\mathbf{\beta})dt}{\sum_{l \in R(t)} h_0(t)\exp(\mathbf{X}_l^T\mathbf{\beta})dt}

= \frac{\exp(\mathbf{X}_i^T\mathbf{\beta})}{\sum_{l \in R(t)} \exp(\mathbf{X}_l^T\mathbf{\beta})}\]</p><p>To have the partial likelihood, we will multiply the conditional probabilities for each time.  For tied events, we used the Breslow approximation which says as follows:  when <span>$\Delta j$</span>​ individuals experience the event at the exact same time <span>$t(j)$</span>​, the​ individuals are treated as if they failed simultaneously.</p><p>The <strong>partial-likelihood function</strong> for the Cox model, accounting for tied event times using Breslow&#39;s approximation, is given by:</p><p class="math-container">\[L(\mathbf{\beta}) = \prod_{j=1}^{k} \left( \frac{\exp(\mathbf{X}_i^T\mathbf{\beta})}{ \sum_{l \in R_j} \exp(\mathbf{X}_l^T\mathbf{\beta})}\right)^{\Delta_i}\]</p><p>where:</p><ul><li><span>$k$</span> is the number of distinct event times.</li><li><span>$t_{(j)}$</span> denotes the j-th distinct ordered event time.</li><li><span>$\Delta_j$</span> is the set of individuals who experience the event at time <span>$t_{(j)}$</span>.</li><li><span>$R_j$</span> is the risk set at time <span>$t_{(j)}$</span>, comprising all individuals who are still at risk (have not yet experienced the event or been censored) just- before <span>$t_{(j)}$</span>.</li><li><span>$\mathbf{X}_i$</span> is the covariate vector for individual <span>$i$</span>.</li></ul><h3 id="5.-The-Loss-Function-(Negative-Log-Partial-Likelihood)"><a class="docs-heading-anchor" href="#5.-The-Loss-Function-(Negative-Log-Partial-Likelihood)">5. The Loss Function (Negative Log-Partial-Likelihood)</a><a id="5.-The-Loss-Function-(Negative-Log-Partial-Likelihood)-1"></a><a class="docs-heading-anchor-permalink" href="#5.-The-Loss-Function-(Negative-Log-Partial-Likelihood)" title="Permalink"></a></h3><p>Our goal is to estimate the regression coefficients <span>$\mathbf{\beta}$</span> by maximizing the partial-likelihood function <span>$L(\mathbf{\beta})$</span>. Equivalently, it is often more convenient to minimize its negative logarithm, which we define as our loss function:</p><p class="math-container">\[\text{Loss}(\mathbf{\beta}) = - \log L(\mathbf{\beta}) \]</p><p>Taking the negative logarithm of the Breslow partial likelihood, we get:</p><p class="math-container">\[
\text{Loss}(\mathbf{\beta}) = - \sum_{i=1}^{n} \Delta_i \left( \mathbf{X}_i^T\mathbf{\beta} - \log \left( \sum_{j \in R_j} \exp(\mathbf{X}_j^T\mathbf{\beta}) \right) \right)
\]</p><p>This function is convex, which facilitates optimization.</p><p>The loss function is coded as follows: </p><pre><code class="language-julia hljs">function loss(beta, M::Cox)
    # M.X: Design matrix (n x m), where n is number of observations, m is number of covariates.
    # M.T: Vector of observed times (n) for each individual.
    # M.Δ: Vector of event indicators (n), 1 if event, 0 if censored.
    η = M.X*beta
    return dot(M.Δ, log.((M.T .&lt;= M.T&#39;) * exp.(η)) .- η)
end</code></pre><h3 id="6.-Gradient-of-the-Loss-Function"><a class="docs-heading-anchor" href="#6.-Gradient-of-the-Loss-Function">6. Gradient of the Loss Function</a><a id="6.-Gradient-of-the-Loss-Function-1"></a><a class="docs-heading-anchor-permalink" href="#6.-Gradient-of-the-Loss-Function" title="Permalink"></a></h3><p>To find the optimal <span>$\mathbf{\beta}$</span>, we need to minimize the loss function. </p><p>The gradient of the loss function with respect to a specific coefficient <span>$\beta_k$</span> is:</p><p class="math-container">\[\frac{\partial}{\partial \beta_k} \text{Loss}(\mathbf{\beta}) = - \sum_{i=1}^{n} \left( X_{ik} - \frac{\sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j) X_{jk}}{\sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j)} \right)\]</p><h3 id="7.-Hessian-Matrix-of-the-Loss-Function"><a class="docs-heading-anchor" href="#7.-Hessian-Matrix-of-the-Loss-Function">7. Hessian Matrix of the Loss Function</a><a id="7.-Hessian-Matrix-of-the-Loss-Function-1"></a><a class="docs-heading-anchor-permalink" href="#7.-Hessian-Matrix-of-the-Loss-Function" title="Permalink"></a></h3><p>For optimization algorithms like Newton-Raphson and for calculating standard errors, the Hessian matrix (matrix of second partial derivatives) of the loss function is required.</p><p>The entry for the <span>$k$</span>-th row and <span>$l$</span>-th column of the Hessian matrix is:</p><p class="math-container">\[\frac{\partial^2}{\partial \beta_k \partial \beta_l} \text{Loss}(\mathbf{\beta}) = \sum_{i=1}^{n} \Delta_i \left[ \frac{\sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j) X_{jk}X_{jl}}{\sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j)} - \frac{\left( \sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j) X_{jk} \right) \left( \sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j) X_{jl} \right)}{\left( \sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j) \right)^2} \right]\]</p><h3 id="8.-Information-Matrix-and-Variance-Covariance-Matrix"><a class="docs-heading-anchor" href="#8.-Information-Matrix-and-Variance-Covariance-Matrix">8. Information Matrix and Variance-Covariance Matrix</a><a id="8.-Information-Matrix-and-Variance-Covariance-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#8.-Information-Matrix-and-Variance-Covariance-Matrix" title="Permalink"></a></h3><p>The observed Information Matrix, <span>$I(\hat{\boldsymbol{\beta}})$</span>, is defined as the negative of the Hessian matrix of the log-likelihood function, evaluated at the maximum likelihood estimates <span>$\hat{\boldsymbol{\beta}}$</span>.</p><p class="math-container">\[I(\hat{\boldsymbol{\beta}}) = -H(\hat{\boldsymbol{\beta}})\]</p><p>But, in the earlier formula, <span>$\mathbf{H}_{\text{Loss}}$</span>​ was for Loss(β), which is -log L(β) <span>$\mathbf{H}_{\text{Loss}} = - \mathbf{H}_{\text{log-likelihood}}$</span>. Therefore, the observed Information Matrix is equal to <span>$\mathbf{H}_{\text{Loss}}$</span> itself.</p><p>The variance (and covariance) of our estimators <span>$\hat{\boldsymbol{\beta}}$</span> are obtained by inverting the observed information matrix.</p><p class="math-container">\[\text{Var}(\hat{\boldsymbol{\beta}}) = I(\hat{\boldsymbol{\beta}})^{-1}\]</p><p>This final matrix contains:</p><ul><li>On its diagonal: the variances of each coefficient (<span>$\text{Var}(\hat{\beta}_1)$</span>, <span>$\text{Var}(\hat{\beta}_2)$</span>, ...).</li><li>Off-diagonal: the covariances between pairs of coefficients.</li></ul><h3 id="9.-Standard-Error"><a class="docs-heading-anchor" href="#9.-Standard-Error">9. Standard Error</a><a id="9.-Standard-Error-1"></a><a class="docs-heading-anchor-permalink" href="#9.-Standard-Error" title="Permalink"></a></h3><p>The standard error for a specific coefficient (<span>$\hat{\beta}_k$</span>) is the square root of its variance.</p><p class="math-container">\[SE(\hat{\beta}_k) = \sqrt{\text{Var}(\hat{\beta}_k)}\]</p><h3 id="10.-Wald-Test-for-Significance"><a class="docs-heading-anchor" href="#10.-Wald-Test-for-Significance">10. Wald Test for Significance</a><a id="10.-Wald-Test-for-Significance-1"></a><a class="docs-heading-anchor-permalink" href="#10.-Wald-Test-for-Significance" title="Permalink"></a></h3><p>To determine if a variable has a statistically significant effect, a Wald test is performed. A z-score is calculated:</p><p class="math-container">\[z = \frac{\text{Coefficient}}{\text{Erreur Type}} = \frac{\hat{\beta}}{SE(\hat{\beta})}\]</p><p>This <span>$z$</span>-score is then compared to a normal distribution to obtain a <span>$p$</span>-value. A low <span>$p$</span>-value (typically &lt; 0.05) suggests that the coefficient is significantly different from zero.</p><p>The p-value for each coefficient is calculated by comparing its z-score to a standard normal distribution. This p-value indicates the probability of observing a z-score as extreme as, or more extreme than, the one calculated, assuming the null hypothesis (that the coefficient is zero) is true.</p><h3 id="11.-Confidence-Interval"><a class="docs-heading-anchor" href="#11.-Confidence-Interval">11. Confidence Interval</a><a id="11.-Confidence-Interval-1"></a><a class="docs-heading-anchor-permalink" href="#11.-Confidence-Interval" title="Permalink"></a></h3><p>The standard error allows for the construction of a confidence interval (CI) around the coefficient, which provides a range of plausible values for the true coefficient.</p><p>The general formula for a <span>$(1 - \alpha) \times 100\%$</span> confidence interval is:</p><p class="math-container">\[\text{IC pour } \hat{\beta} = \hat{\beta} \pm z_{\alpha/2} \times SE(\hat{\beta})\]</p><p>Let us see for example the output on the <code>colon</code> dataset: </p><pre><code class="language-julia hljs">using SurvivalModels
using RDatasets

# ovarian = dataset(&quot;survival&quot;, &quot;ovarian&quot;)
# ovarian.FUTime = Float64.(ovarian.FUTime)
# ovarian.FUStat = Bool.(ovarian.FUStat)
# model = fit(Cox, @formula(Surv(FUTime, FUStat) ~ Age + ECOG_PS), ovarian)

colon = dataset(&quot;survival&quot;, &quot;colon&quot;)
colon.Time = Float64.(colon.Time)
colon.Status = Bool.(colon.Status)
model_colon = fit(Cox, @formula(Surv(Time, Status) ~ Age + Rx), colon)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Cox Model (n: 1858, m: 3, method: SurvivalModels.CoxV3, C-index: 0.5435170918176299)
</code></pre><p>The outputed dataframe contains columns with respectively the name of the predictor, the obtained coefficients, its standard error, the associated p-value and the test statistic z as just described. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SurvivalModels.CoxMethod" href="#SurvivalModels.CoxMethod"><code>SurvivalModels.CoxMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StatsBase.fit(Cox, @formula(Surv(T,Δ)~predictors), dataset)</code></pre><p>Arguments: </p><ul><li>T: The Cox model type to fit (CoxV3)</li><li>formula: A StatsModels.FormulaTerm specifying the survival model</li><li>df: A DataFrame containing the variables specified in the formula</li></ul><p>Returns: </p><ul><li><p>predictor: A Vector{String} containing the names of the predictor variables included in the model</p></li><li><p>beta: A Vector{Float64} containing the estimated regression coefficients (β​) for each predictor</p></li><li><p>se: A Vector{Float64} containing the standard errors of the estimated regression coefficients</p></li><li><p>loglikelihood: A Vector{Float64} containing the log-likelihood of the fitted model. This value is repeated for each predictor row </p></li><li><p>coef: A vector of the estimated coefficients</p></li><li><p>formula: The applied formula</p></li></ul><p>Example:</p><pre><code class="language-julia hljs">ovarian = dataset(&quot;survival&quot;, &quot;ovarian&quot;)
ovarian.FUTime = Float64.(ovarian.FUTime) (Time column needs to be Float64 type)
ovarian.FUStat = Bool.(ovarian.FUStat) (Status column needs to be Bool type)
model = fit(Cox, @formula(Surv(FUTime, FUStat) ~ Age + ECOG_PS), ovarian)</code></pre><p>Types: </p><ul><li>Cox : the base abstract type</li><li>CoxGrad&lt;:Cox : abstract type for Cox models that are solved using gradient-based optimization</li><li>CoxLLH&lt;:CoxGrad : abstract type for Cox models that are solved by optimizing the log-likelihood</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/4fe356de3b3ef3879b024866acfb3234cbf2ba1e/src/Semiparametric/Cox.jl#L1-L32">source</a></section></article><h2 id="Different-versions-of-the-optimisation-routine"><a class="docs-heading-anchor" href="#Different-versions-of-the-optimisation-routine">Different versions of the optimisation routine</a><a id="Different-versions-of-the-optimisation-routine-1"></a><a class="docs-heading-anchor-permalink" href="#Different-versions-of-the-optimisation-routine" title="Permalink"></a></h2><p>To implement the Cox proportional hazards model, different versions were coded, using different methods. The final goal is to compare these versions and choose the most efficient one: the fastest and the closest to the true values of the coefficients. </p><h3 id="V0:-Derivative-Free-Optimization-with-Nelder-Mead"><a class="docs-heading-anchor" href="#V0:-Derivative-Free-Optimization-with-Nelder-Mead">V0: Derivative-Free Optimization with Nelder-Mead</a><a id="V0:-Derivative-Free-Optimization-with-Nelder-Mead-1"></a><a class="docs-heading-anchor-permalink" href="#V0:-Derivative-Free-Optimization-with-Nelder-Mead" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SurvivalModels.CoxV0" href="#SurvivalModels.CoxV0"><code>SurvivalModels.CoxV0</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoxVO(T, Δ, X)
fit(CoxV0, @formula(Surv(T,Δ)~X), data = ...)</code></pre><p>An implementation of the Cox proportional hazards model that minimizes the negative partial log-likelihood function (<code>cox_nllh</code>). This version uses the Nelder-Mead method, a derivative-free optimization algorithm. </p><p>Fields: </p><ul><li>X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features</li><li>T::Vector{Float64}: The observed times, sorted in ascending order </li><li>Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/4fe356de3b3ef3879b024866acfb3234cbf2ba1e/src/Semiparametric/Cox/v0.jl#L1-L12">source</a></section></article><h3 id="V1:-Implementation-using-the-&#39;Optimization.jl&#39;-Julia-package"><a class="docs-heading-anchor" href="#V1:-Implementation-using-the-&#39;Optimization.jl&#39;-Julia-package">V1: Implementation using the &#39;Optimization.jl&#39; Julia package</a><a id="V1:-Implementation-using-the-&#39;Optimization.jl&#39;-Julia-package-1"></a><a class="docs-heading-anchor-permalink" href="#V1:-Implementation-using-the-&#39;Optimization.jl&#39;-Julia-package" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SurvivalModels.CoxV1" href="#SurvivalModels.CoxV1"><code>SurvivalModels.CoxV1</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoxV1(T, Δ, X)
fit(CoxV1, @formula(Surv(T,Δ)~X), data = ...)</code></pre><p>The first implementation of the Cox proportional hazards model uses optimization libraries (Optimization.jl, Optim.jl) for coefficient estimation. It uses the BFGS algorithm to minimize the negative partial log-likelihood. </p><p>Fields: </p><ul><li>X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features.</li><li>T::Vector{Float64}: The observed times, sorted in ascending order</li><li>Δ::Vector{Int64}: The event indicator vector (true for event, false for censoring)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/4fe356de3b3ef3879b024866acfb3234cbf2ba1e/src/Semiparametric/Cox/v1.jl#L1-L12">source</a></section></article><h3 id="V2:-Implementation-using-the-gradient-and-the-Hessian-matrix"><a class="docs-heading-anchor" href="#V2:-Implementation-using-the-gradient-and-the-Hessian-matrix">V2: Implementation using the gradient and the Hessian matrix</a><a id="V2:-Implementation-using-the-gradient-and-the-Hessian-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#V2:-Implementation-using-the-gradient-and-the-Hessian-matrix" title="Permalink"></a></h3><p>For this version the Hessian Matrix was directly implemented. Its complexity is O(n2m2) which makes it the slowest version.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SurvivalModels.CoxV2" href="#SurvivalModels.CoxV2"><code>SurvivalModels.CoxV2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoxV2(T, Δ, X)
fit(CoxV2, @formula(Surv(T,Δ)~X), data = ...)</code></pre><p>The second implementation of the Cox proportional hazards model uses a Newton-Raphson-like iterative update that directly calculates and utilizes the gradient and Hessian matrix. This version is updating coefficients via the update! function.</p><p>Fields:</p><ul><li>X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features</li><li>T::Vector{Float64}: The observed times, sorted in ascending order</li><li>Δ::Vector{Int64}: The event indicator vector (true for event, false for censoring)</li><li>R::BitMatrix: A boolean risk matrix, where &#39;R[i,j]&#39; is &#39;true&#39; if individual &#39;j&#39; is at risk at time &#39;T[i]&#39;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/4fe356de3b3ef3879b024866acfb3234cbf2ba1e/src/Semiparametric/Cox/v2.jl#L1-L12">source</a></section></article><h3 id="V3:-Improved-version-of-V2-(much-faster)-because-non-allocative."><a class="docs-heading-anchor" href="#V3:-Improved-version-of-V2-(much-faster)-because-non-allocative.">V3: Improved version of V2 (much faster) because non-allocative.</a><a id="V3:-Improved-version-of-V2-(much-faster)-because-non-allocative.-1"></a><a class="docs-heading-anchor-permalink" href="#V3:-Improved-version-of-V2-(much-faster)-because-non-allocative." title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SurvivalModels.CoxV3" href="#SurvivalModels.CoxV3"><code>SurvivalModels.CoxV3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoxV3(T, Δ, X)
fit(CoxV3, @formula(Surv(T,Δ)~X), data = ...)
fit(Cox, @formula(Surv(T,Δ)~X), data = ...)</code></pre><p>The third implementation of the Cox proportional hazards model represents a highly optimized and significantly faster iteration compared to previous implementation, CoxV2.</p><p>This is the default implementation called when you ask for a Cox model. </p><p>Fields:</p><ul><li>Xᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)</li><li>sX::Vector{Float64}: Sum of X&#39; multiplied by Δ</li><li>T::Vector{Float64}: The observed times sorted in descending order</li><li>Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)</li><li>loss::Vector{Float64}: Stores the current negative partial log-likelihood value</li><li>G::Vector{Float64}: Stores the gradient vector  </li><li>H::Matrix{Float64}: Stores the Hessian matrix </li><li>S₁::Vector{Float64}: Sum of rⱼxₖⱼ</li><li>S₂::Matrix{Float64}: Sum of rⱼxₖⱼ * xⱼ</li><li>μ::Vector{Float64}: Updates the gradient and Hessian</li><li>η::Vector{Float64}: ηi = Xiβ</li><li>r::Vector{Float64}: ri = exp(ηi)</li><li>R::Vector{UnitRange{Int64}}: A vector of the risk ranges for each output time.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/4fe356de3b3ef3879b024866acfb3234cbf2ba1e/src/Semiparametric/Cox/v3.jl#L1-L24">source</a></section></article><h3 id="V4:-Majoration-of-the-Hessian-matrix-by-a-universal-bound."><a class="docs-heading-anchor" href="#V4:-Majoration-of-the-Hessian-matrix-by-a-universal-bound.">V4: Majoration of the Hessian matrix by a universal bound.</a><a id="V4:-Majoration-of-the-Hessian-matrix-by-a-universal-bound.-1"></a><a class="docs-heading-anchor-permalink" href="#V4:-Majoration-of-the-Hessian-matrix-by-a-universal-bound." title="Permalink"></a></h3><p>Coding the Hessian Matrix for the CoxV2 was very impratical, so for this version we tried a different approach: </p><p>The Hessian Matrix simplifies for the diagonal terms as folllows: </p><p class="math-container">\[\frac{\partial^2 \text{Loss}(\mathbf{\beta})}{\partial \beta_k^2} = \sum_{i=1}^{n} \Delta_i \left[ \frac{\sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j) X_{jk}^2}{\sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j)} - \left( \frac{\sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j) X_{jk}}{\sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j)} \right)^2 \right]\]</p><p>This can be expressed using the concept of variance. </p><p class="math-container">\[\frac{\partial^2 \text{Loss}(\mathbf{\beta})}{\partial \beta_k^2} = \sum_{i=1}^{n} \Delta_i \left[ \sum_{j \in R_i} A_j X_{jk}^2 - \left( \sum_{j \in R_i} A_j X_{jk} \right)^2 \right]\]</p><p>with:</p><p class="math-container">\[A_{j} = \frac{\exp(\mathbf{\beta}^T\mathbf{X}_j)}{\sum_{j \in R_i} \exp(\mathbf{\beta}^T\mathbf{X}_j)}\]</p><p>The upper bound for the variance of a variable <span>$X$</span> on an interval <span>$[a,b]$</span> is given by:</p><p class="math-container">\[\text{Var}(X) \le \frac{1}{4}(b-a)^2\]</p><p>Applying this bound to the diagonal Hessian elements, we get an approximation for the k-th diagonal element, B_k:</p><p class="math-container">\[B_k = \sum_{i=1}^n \frac{1}{4} \Delta_i \left( \max_{j \in R_i} X_{jk} - \min_{j \in R_i} X_{jk} \right)^2\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SurvivalModels.CoxV4" href="#SurvivalModels.CoxV4"><code>SurvivalModels.CoxV4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoxV4(T, Δ, X)
fit(CoxV4, @formula(Surv(T,Δ)~X), data = ...)</code></pre><p>The fourth implementation of the Cox proportional hazards model uses Hessian approximation based on a pre-calculated estimation. This version was created for when it might be difficult to work with full Hessian , offering faster iterations by using a Hessian approximation.</p><p>Fields:</p><ul><li>X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features</li><li>T::Vector{Float64}: The observed times sorted in ascending order</li><li>Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)</li><li>sX::Vector{Float64}: Sum of X&#39; multiplied by Δ</li><li>G::Vector{Float64}: Stores the gradient vector</li><li>η::Vector{Float64}: ηi = Xiβ</li><li>A::Vector{Float64}: Ai = exp(ηi)</li><li>B::Vector{Float64}: Stores the majoration elements of the Hessian matrix</li><li>C::Vector{Float64}: Used in the mkA! function</li><li>K::Vector{Int64}: Number of events at each unique observed event time</li><li>loss::Vector{Float64}: Stores the current negative partial log-likelihood value, used in CoxLLH getβ</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/4fe356de3b3ef3879b024866acfb3234cbf2ba1e/src/Semiparametric/Cox/v4.jl#L1-L19">source</a></section></article><h3 id="V5"><a class="docs-heading-anchor" href="#V5">V5</a><a id="V5-1"></a><a class="docs-heading-anchor-permalink" href="#V5" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SurvivalModels.CoxV5" href="#SurvivalModels.CoxV5"><code>SurvivalModels.CoxV5</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoxV5(T, Δ, X)
fit(CoxV5, @formula(Surv(T,Δ)~X), data = ...)</code></pre><p>The fifth implementation of the Cox proportional hazards model uses a pre-calculated Hessian approximation for faster iterations, like CoxV4. Its approach is similar to CoxV3.</p><p>Fields:</p><ul><li>Xᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)</li><li>sX::Vector{Float64}: Sum of X&#39; multiplied by Δ</li><li>T::Vector{Float64}: The observed times sorted in descending order</li><li>Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)</li><li>loss::Vector{Float64}: Stores the current negative partial log-likelihood value</li><li>G::Vector{Float64}: Stores the gradient vector.</li><li>S₁::Vector{Float64}:  Sum of rⱼxₖⱼ</li><li>μ::Vector{Float64}: Currently unused in <code>update!</code> function</li><li>η::Vector{Float64}: ηi = Xiβ</li><li>r::Vector{Float64}: ri = exp(ηi)</li><li>R::Vector{UnitRange{Int64}}:</li><li>B::Vector{Float64}: Stores the majoration elements of the Hessian matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/4fe356de3b3ef3879b024866acfb3234cbf2ba1e/src/Semiparametric/Cox/v5.jl#L1-L20">source</a></section></article><h2 id="Comparison-of-the-different-methods-speed"><a class="docs-heading-anchor" href="#Comparison-of-the-different-methods-speed">Comparison of the different methods speed</a><a id="Comparison-of-the-different-methods-speed-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-of-the-different-methods-speed" title="Permalink"></a></h2><p>We propose to compare the different methods on simulated data, with varying number of lines and columns, to verify empirically the theoretical complexity of the different methods.  We will then compare the results with Julia&#39;s and R&#39;s existing Cox implementation.</p><p>We will start by coding our Julia and R structures: </p><pre><code class="language-julia hljs">using SurvivalModels, Plots, Random, Distributions, StatsBase, LinearAlgebra, DataFrames, RCall, Survival
using SurvivalModels: getβ, CoxV0, CoxV1, CoxV2, CoxV3, CoxV4, CoxV5</code></pre><p>We add specific code to compare with <code>Survival.jl</code> and also <code>R::survival::coxph()</code>:</p><pre><code class="language-julia hljs">struct CoxVJ&lt;:SurvivalModels.CoxMethod
    T::Vector{Float64}
    Δ::Vector{Bool}
    X::Matrix{Float64}
    function CoxVJ(T,Δ,X)
        new(T,Bool.(Δ),X)
    end
end

function SurvivalModels.getβ(M::CoxVJ)
    return fit(Survival.CoxModel, M.X, Survival.EventTime.(M.T,M.Δ)).β
end

R&quot;&quot;&quot;
library(survival)
&quot;&quot;&quot;

struct CoxVR&lt;:SurvivalModels.CoxMethod
    df::DataFrame
    function CoxVR(T,Δ,X)
        df = DataFrame(X,:auto)
        df.status = Δ
        df.time = T
        new(df)
    end
end

function SurvivalModels.getβ(M::CoxVR)
    df = M.df
    @rput df
    R&quot;&quot;&quot;
    beta  &lt;- coxph(Surv(time,status)~., data = df, ties=&quot;breslow&quot;)$coefficients
    &quot;&quot;&quot;
    @rget beta
    return beta
end</code></pre><p>Then, we will simulate our data and then run our models:</p><pre><code class="language-julia hljs"># Creating a dictionary for all the models:
# Label =&gt; (constructor, plotting color)

const design = Dict(
&quot;V0&quot;=&gt; (CoxV0, :blue),
&quot;V1&quot;=&gt; (CoxV1, :orange),
&quot;V2&quot;=&gt; (CoxV2, :brown),
&quot;V3&quot;=&gt; (CoxV3, :purple),
&quot;V4&quot;=&gt; (CoxV4, :green),
&quot;V5&quot;=&gt; (CoxV5, :yellow),
&quot;VR&quot;=&gt; (CoxVR, :red),
&quot;VJ&quot;=&gt; (CoxVJ, :black)
);


function simulate_survival_data(n, m; β=ones(m))
    X = randn(n,m)
    O = rand.(Exponential.(exp.(.- X * β)))
    C = rand(Exponential(1/3),n)
    T = min.(O, C)
    Δ = Bool.(O .&lt;= C)
    return (T, Δ, X)
end

# Run the models and get the running time, the β coefficients and the difference between the true β and the obtained ones:
function run_models()
    Ns = (1000, 2000, 4000)
    Ms = (5,10,20)
    true_betas = randn(maximum(Ms))
    df = []
    for n in Ns, m in Ms
        if (n == 2000) | (m == 10) # Only if they end up in the graphs.
            data = simulate_survival_data(n,m, β = true_betas[1:m])
            for (name, (constructor, _)) in design
                display((n,m,name))
                model = constructor(data...)
                beta = getβ(model)
                time = @elapsed getβ(model)
                push!(df, (
                    n = n,
                    m = m,
                    name = name,
                    time = time,
                    beta = beta,
                    diff_to_truth = sqrt(sum((beta .- true_betas[1:m]).^2)/sum(true_betas[1:m].^2)),
                ))
            end
        end
    end
    df = DataFrame(df)
    sort!(df, :name)
    return df
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">run_models (generic function with 1 method)</code></pre><p>The first graph will compare how long it takes for all the implementations to run on datasets that have maximum 2000 observations and 20 covariates.</p><pre><code class="language-julia hljs"># Plot the results, starting with the time:
function timing_graph(df)
    group1 = groupby(filter(r -&gt; r.m==10, df), :name)
    p1 = plot(; xlabel = &quot;Number of observations (n)&quot;,
        ylabel = &quot;Time (in seconds)&quot;,
        yscale= :log10,
        xscale= :log10,
        title = &quot;For m=20 covs., varying n&quot;,
        legend = :bottomright,
        lw = 1);
    for g in group1
        plot!(p1, g.n, g.time, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)
    end
    group2 = groupby(filter(r -&gt; r.n==2000, df), :name)
        p2 = plot(; xlabel = &quot;Number of covariates (m)&quot;,
            ylabel = &quot;Temps (ms)&quot;,
            yscale= :log10,
            xscale= :log10,
            title = &quot;For n=2000 obs., varying m&quot;,
            legend = :bottomright,
            lw = 1);
        for g in group2
            plot!(p2, g.m, g.time, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)
        end
        p = plot(p1,p2, size=(1200,600), plot_title = &quot;Runtime (logscale) of the various implementations&quot;)
        return p
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">timing_graph (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">df = run_models()
timing_graph(df)</code></pre><img src="333f5315.svg" alt="Example block output"/><p>We can the that CoxV3 is the fastest, while CoxV2 is the slowest. We will zoom on our implementation vs Survival.jl vs R::survival: </p><pre><code class="language-julia hljs">timing_graph(filter(r -&gt; r.name ∈ (&quot;V4&quot;, &quot;V3&quot;, &quot;VJ&quot;, &quot;VR&quot;), df))</code></pre><img src="8a183cc7.svg" alt="Example block output"/><p>So we are about x10 faster than the reference implementation of R (and than the previous Julia versions) on this example. </p><pre><code class="language-julia hljs">function beta_correctness_graphs(df; ref=&quot;VJ&quot;)

    reflines = filter(r -&gt; r.name == ref, df)
    rename!(reflines, :beta =&gt; :refbeta)
    select!(reflines, Not([:name, :time, :diff_to_truth]))
    otherlines = filter(r -&gt; r.name != ref, df)
    rez = leftjoin(otherlines, reflines, on=[:n,:m])
    percent(x,y) = sqrt(sum((x .- y).^2)/sum(y .^2))
    rez.error = percent.(rez.beta, rez.refbeta)
    select!(rez, [:n,:m,:name,:error])
    rez = filter!(r -&gt; !isnan(r.error), rez)

    group1 = groupby(filter(r -&gt; r.m==20, rez), :name)
    p1 = plot(; xlabel = &quot;Number of observations (n)&quot;,
                ylabel = &quot;L2dist to $ref&#39;s β&quot;,
                yscale=:log10,
                xscale= :log10,
                title = &quot;m=20, varying n&quot;,
                legend = :bottomright,
                lw = 1);
    for g in group1
        plot!(p1, g.n, g.error, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)
    end

    group2 = groupby(filter(r -&gt; r.n==2000, rez), :name)
    p2 = plot(; xlabel = &quot;Nomber of covariates (m)&quot;,
                ylabel = &quot;L2Dist to $ref&#39;s β&quot;,
                yscale=:log10,
                xscale= :log10,
                title = &quot;n=2000, varying m&quot;,
                legend = :bottomright,
                lw = 1);
    for g in group2
        plot!(p2, g.m, g.error, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)
    end
    p = plot(p1,p2, size=(1200,600), plot_title=&quot;β-correctness w.r.t. $ref&#39;s version.&quot;)
    return p
end

#beta_correctness_graphs(df)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">beta_correctness_graphs (generic function with 1 method)</code></pre><p>We will compare the diffferent models&#39; coefficents values with the &quot;right&quot; beta value that we obtained while simulating our data.</p><pre><code class="language-julia hljs">function beta_wrt_truth(df)
    group1 = groupby(filter(r -&gt; r.m==10, df), :name)
    p1 = plot(; xlabel = &quot;Number of observations (n)&quot;,
                ylabel = &quot;L2dist to the truth&quot;,
                yscale=:log10,
                xscale= :log10,
                title = &quot;m=20, varying n&quot;,
                legend = :bottomright,
                lw = 1,
                plot_title=&quot;β-correctness w.r.t. the truth.&quot;);
    for g in group1
        plot!(p1, g.n, g.diff_to_truth, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)
    end

    return p1
end

beta_wrt_truth(df)</code></pre><img src="4b6809ff.svg" alt="Example block output"/><h2 id="Model-Evaluation:-Harrell&#39;s-Concordance-Index-(C-index)"><a class="docs-heading-anchor" href="#Model-Evaluation:-Harrell&#39;s-Concordance-Index-(C-index)">Model Evaluation: Harrell&#39;s Concordance Index (C-index)</a><a id="Model-Evaluation:-Harrell&#39;s-Concordance-Index-(C-index)-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Evaluation:-Harrell&#39;s-Concordance-Index-(C-index)" title="Permalink"></a></h2><p>A key metric for assessing the predictive discrimination of a Cox model is <strong>Harrell&#39;s concordance index (C-index)</strong>.   The C-index measures the proportion of all usable patient pairs in which the predictions and outcomes are concordant: it is the probability that, for a randomly chosen pair of comparable subjects, the subject with the higher predicted risk actually experiences the event before the other. Tied risk scores count as half-concordant.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SurvivalModels.harrells_c" href="#SurvivalModels.harrells_c"><code>SurvivalModels.harrells_c</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">harrells_c(times, statuses, risk_scores)
harrels_c(C::Cox)</code></pre><p>Compute Harrell&#39;s concordance index (C-index) for survival models.</p><p><strong>Arguments</strong></p><ul><li><code>times</code>: Vector of observed times (Float64).</li><li><code>statuses</code>: Vector of event indicators (Bool; true if event, false if censored).</li><li><code>risk_scores</code>: Vector of predicted risk scores (higher means higher risk).</li></ul><p><strong>Returns</strong></p><ul><li>The C-index, a value between 0 and 1 indicating the proportion of all usable patient pairs in which predictions and outcomes are concordant.</li></ul><p><strong>Details</strong></p><p>The C-index measures the discriminative ability of a survival model: it is the probability that, for a randomly chosen pair of comparable subjects, the subject with the higher predicted risk actually experiences the event before the other. Tied risk scores count as half-concordant.</p><p>You can also call <code>harrels_c(C::Cox)</code> to compute the C-index for a fitted Cox model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSurv/SurvivalModels.jl/blob/4fe356de3b3ef3879b024866acfb3234cbf2ba1e/src/utils.jl#L2-L21">source</a></section></article><p>The C-index ranges from 0.5 (no better than random) to 1.0 (perfect discrimination). It is outputed by the show function, and can be queried seprately too: </p><p>You can compute the C-index for a fitted Cox model using:</p><pre><code class="language-julia hljs">model = fit(Cox, @formula(Surv(Time, Status) ~ Age + Rx), colon)
cindex = SurvivalModels.harrells_c(model)
model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Cox Model (n: 1858, m: 3, method: SurvivalModels.CoxV3, C-index: 0.5435170918176299)
</code></pre><p>A higher C-index indicates better predictive discrimination.</p><div class="citation noncanonical"><dl><dt>[4]</dt><dd><div>D. R. Cox. <em>Regression models and life-tables</em>. Journal of the Royal Statistical Society: Series B (Methodological) <strong>34</strong>, 187–202 (1972).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../nonparametric/logranktest/">« Log-Rank Test</a><a class="docs-footer-nextpage" href="../../parametric/generalhazard/">General Hazard »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 23 July 2025 11:55">Wednesday 23 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
