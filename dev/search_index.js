var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/#SurvivalModels.Cox-references","page":"References","title":"SurvivalModels.Cox","text":"StatsBase.fit(Cox, @formula(Surv(T,Δ)~predictors), dataset)\n\narguments: \n- T: The Cox model type to fit (CoxV3)\n- formula: A StatsModels.FormulaTerm specifying the survival model\n- df: A DataFrame containing the variables specified in the formula\n\nreturns: \n- predictor: A Vector{String} containing the names of the predictor variables included in the model\n- beta: A Vector{Float64} containing the estimated regression coefficients (β​) for each predictor\n- se: A Vector{Float64} containing the standard errors of the estimated regression coefficients\n- loglikelihood: A Vector{Float64} containing the log-likelihood of the fitted model. This value is repeated for each predictor row \n\n- coef: A vector of the estimated coefficients\n- formula: The applied formula\n\nExample: ovarian = dataset(\"survival\", \"ovarian\") ovarian.FUTime = Float64.(ovarian.FUTime) (Time column needs to be Float64 type) ovarian.FUStat = Bool.(ovarian.FUStat) (Status column needs to be Bool type) model = fit(Cox, @formula(Surv(FUTime, FUStat) ~ Age + ECOG_PS), ovarian)\n\nTypes: \n\nCox : the base abstract type\nCoxGrad<:Cox : abstract type for Cox models that are solved using gradient-based optimization\nCoxLLH<:CoxGrad : abstract type for Cox models that are solved by optimizing the log-likelihood\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV0-references","page":"References","title":"SurvivalModels.CoxV0","text":"CoxVO(T, Δ, X)\nfit(CoxV0, @formula(Surv(T,Δ)~X), data = ...)\n\nAn implementation of the Cox proportional hazards model that minimizes the negative partial log-likelihood function (cox_nllh). This version uses the Nelder-Mead method, a derivative-free optimization algorithm. \n\nFields:      - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features     - T::Vector{Float64}: The observed times, sorted in ascending order      - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV1-references","page":"References","title":"SurvivalModels.CoxV1","text":"CoxV1(T, Δ, X)\nfit(CoxV1, @formula(Surv(T,Δ)~X), data = ...)\n\nThe first implementation of the Cox proportional hazards model uses optimization libraries (Optimization.jl, Optim.jl) for coefficient estimation. It uses the BFGS algorithm to minimize the negative partial log-likelihood. \n\nFields:      - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features.     - T::Vector{Float64}: The observed times, sorted in ascending order     - Δ::Vector{Int64}: The event indicator vector (true for event, false for censoring)\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV2-references","page":"References","title":"SurvivalModels.CoxV2","text":"CoxV2(T, Δ, X)\nfit(CoxV2, @formula(Surv(T,Δ)~X), data = ...)\n\nThe second implementation of the Cox proportional hazards model uses a Newton-Raphson-like iterative update that directly calculates and utilizes the gradient and Hessian matrix. This version is updating coefficients via the update! function.\n\nFields:     - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features     - T::Vector{Float64}: The observed times, sorted in ascending order     - Δ::Vector{Int64}: The event indicator vector (true for event, false for censoring)     - R::BitMatrix: A boolean risk matrix, where 'R[i,j]' is 'true' if individual 'j' is at risk at time 'T[i]'\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV3-references","page":"References","title":"SurvivalModels.CoxV3","text":"CoxV3(T, Δ, X)\nfit(CoxV3, @formula(Surv(T,Δ)~X), data = ...)\nfit(Cox, @formula(Surv(T,Δ)~X), data = ...)\n\nThe third implementation of the Cox proportional hazards model represents a highly optimized and significantly faster iteration compared to previous implementation, CoxV2.\n\nThis is the default implementation called when you ask for a Cox model. \n\nFields:     - Xᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)     - sX::Vector{Float64}: Sum of X' multiplied by Δ     - T::Vector{Float64}: The observed times sorted in descending order     - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)     - loss::Vector{Float64}: Stores the current negative partial log-likelihood value     - G::Vector{Float64}: Stores the gradient vector       - H::Matrix{Float64}: Stores the Hessian matrix      - S₁::Vector{Float64}: Sum of rⱼxₖⱼ     - S₂::Matrix{Float64}: Sum of rⱼxₖⱼ * xⱼ     - μ::Vector{Float64}: Updates the gradient and Hessian     - η::Vector{Float64}: ηi = Xiβ     - r::Vector{Float64}: ri = exp(ηi)     - R::Vector{UnitRange{Int64}}: A vector of the risk ranges for each output time.\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV4-references","page":"References","title":"SurvivalModels.CoxV4","text":"CoxV4(T, Δ, X)\nfit(CoxV4, @formula(Surv(T,Δ)~X), data = ...)\n\nThe fourth implementation of the Cox proportional hazards model uses Hessian approximation based on a pre-calculated estimation. This version was created for when it might be difficult to work with full Hessian , offering faster iterations by using a Hessian approximation.\n\nFields:     - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features     - T::Vector{Float64}: The observed times sorted in ascending order     - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)     - sX::Vector{Float64}: Sum of X' multiplied by Δ     - G::Vector{Float64}: Stores the gradient vector     - η::Vector{Float64}: ηi = Xiβ     - A::Vector{Float64}: Ai = exp(ηi)     - B::Vector{Float64}: Stores the majoration elements of the Hessian matrix     - C::Vector{Float64}: Used in the mkA! function     - K::Vector{Int64}: Number of events at each unique observed event time     - loss::Vector{Float64}: Stores the current negative partial log-likelihood value, used in CoxLLH getβ\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV5-references","page":"References","title":"SurvivalModels.CoxV5","text":"CoxV5(T, Δ, X)\nfit(CoxV5, @formula(Surv(T,Δ)~X), data = ...)\n\nThe fifth implementation of the Cox proportional hazards model uses a pre-calculated Hessian approximation for faster iterations, like CoxV4. Its approach is similar to CoxV3.\n\nFields:     - Xᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)     - sX::Vector{Float64}: Sum of X' multiplied by Δ     - T::Vector{Float64}: The observed times sorted in descending order     - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)     - loss::Vector{Float64}: Stores the current negative partial log-likelihood value     - G::Vector{Float64}: Stores the gradient vector.     - S₁::Vector{Float64}:  Sum of rⱼxₖⱼ     - μ::Vector{Float64}: Currently unused in update! function     - η::Vector{Float64}: ηi = Xiβ     - r::Vector{Float64}: ri = exp(ηi)     - R::Vector{UnitRange{Int64}}:     - B::Vector{Float64}: Stores the majoration elements of the Hessian matrix\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.KaplanMeier-references","page":"References","title":"SurvivalModels.KaplanMeier","text":"KaplanMeier(T, Δ)\nfit(KaplanMeier, @formula(Surv(T, Δ) ~ 1), df)\n\nEfficient Kaplan-Meier estimator.\n\nMathematical Description\n\nSuppose we observe n individuals, with observed times T_1 T_2 ldots T_n and event indicators Delta_1 Delta_2 ldots Delta_n (Delta_i = 1 if the event occurred, 0 if censored).\n\nLet t_1  t_2  cdots  t_k be the ordered unique event times.\n\nd_j: number of events at time t_j\nY_j: number of individuals at risk just before t_j\n\nThe Kaplan-Meier estimator of the survival function S(t) is:\n\nhatS(t) = prod_t_j leq t left(1 - fracd_jY_jright)\n\nThis product runs over all event times t_j less than or equal to t.\n\nThe Greenwood estimator for the variance of hatS(t) is:\n\nwidehatmathrmVarhatS(t) = hatS(t)^2 sum_t_j leq t fracd_jY_j (Y_j - d_j)\n\nArguments\n\nT: Vector of event or censoring times.\nΔ: Event indicator vector (1 if event, 0 if censored).\n\nStores\n\nt: Sorted unique event times.\n∂N: Number of uncensored deaths at each time point.\nY: Number of at risk individuals at each time point.\n∂Λ: Increments of cumulative hazard.\n∂σ: Greenwood variance increments.\n\nExample: Direct usage\n\nusing SurvivalModels\nT = [2, 3, 4, 5, 8]\nΔ = [1, 1, 0, 1, 0]\nkm = KaplanMeier(T, Δ)\n\nExample: Using the fit() interface\n\nusing SurvivalModels, DataFrames, StatsModels\ndf = DataFrame(time=T, status=Δ)\nkm2 = fit(KaplanMeier, @formula(Surv(time, status) ~ 1), df)\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.LogRankTest-references","page":"References","title":"SurvivalModels.LogRankTest","text":"LogRankTest(T, Δ, group, strata)\nfit(LogRankTest, @formula(Surv(T, Δ) ~ gr), data = ...)\nfit(LogRankTest, @formula(Surv(T, Δ) ~ Strata(st) + gr), data = ...)\n\nPerforms the stratified log-rank test for comparing survival distributions across groups.\n\nArguments\n\nT: Vector of observed times.\nΔ: Vector of event indicators (1 = event, 0 = censored).\ngroup: Vector indicating group membership (e.g., treatment arm).\nstrata: Vector indicating strata membership (e.g., baseline strata).\ngr and st are the variables in the DataFrame defining the groups and strata for the fit interface.\n\nReturns\n\nA LogRankTest object with the following fields:\n\nstat: Chi-square test statistic.\ndf: Degrees of freedom (number of groups minus 1).\npval: P-value of the test.\n\nNotes\n\nImplements the stratified log-rank test by aggregating test statistics and variances over strata.\nSuitable for right-censored survival data with stratification.\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.greenwood-Tuple{KaplanMeier, Any}-references","page":"References","title":"SurvivalModels.greenwood","text":"greenwood(S::KaplanMeier, t)\n\nCompute the Greenwood variance estimate for the Kaplan-Meier survival estimator at time t.\n\nThe Greenwood formula provides an estimate of the variance of the Kaplan-Meier survival function at a given time point. For a fitted Kaplan-Meier object S, the variance at time t is:\n\n```math \\widehat{\\mathrm{Var}}[\\hat{S}(t)] = \\hat{S}(t)^2 \\sum{tj < t} \\frac{dj}{Yj (Yj - dj)}\n\n\n\n\n\n","category":"method"},{"location":"references/","page":"References","title":"References","text":"D. R. Cox. Regression models and life-tables. Journal of the Royal Statistical Society: Series B (Methodological) 34, 187–202 (1972).\n\n\n\nE. L. Kaplan and P. Meier. Nonparametric estimation from incomplete observations. Journal of the American statistical association 53, 457–481 (1958).\n\n\n\nM. Greenwood. The natural duration of cancer. Reports on Public Health and Medical Subjects 33, 1–26 (1926).\n\n\n\nN. Mantel. Evaluation of survival data and two new rank order statistics arising in its consideration. Cancer chemotherapy reports 50, 163–170 (1966).\n\n\n\n","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"case_study/#Case-study:-the-colon-dataset.","page":"Case Study","title":"Case study: the colon dataset.","text":"","category":"section"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Consider the following dataset: ","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"using SurvivalModels, RDatasets, Plots\ncolon = dataset(\"survival\", \"colon\")\ncolon.Time = Float64.(colon.Time)\ncolon.Status = Bool.(colon.Status)\nnames(colon)","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"We can first get the Kaplan-Meier estimates. Note that the object only stores ∂Λ, the estimated hazards, so that you have to use the folliwng to get survival rates: ","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"km = fit(KaplanMeier, @formula(Surv(Time, Status)~1), colon)\nplot(km.t, cumprod(1 .- km.∂Λ), title = \"Kaplan-Meier estimator\", xlabel=\"Time t\", ylabel=\"Survival curve S(t)\")","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Alternatively, you can also consider the whole object km as being the survival function: ","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"[km(1000), km(2000)]","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"More generally: ","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"all(km.(km.t[2:end]) .== cumprod(1 .- km.∂Λ)[1:end-1])","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Back to our example. What does this thing show ? ","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"What variable can we use ? ","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"This case study is still a work in progress and should be completed with log-rank tests, cox, and other type of analysis... ","category":"page"},{"location":"nonparametric/logranktest/#Log-Rank-Test","page":"Log-Rank Test","title":"Log-Rank Test","text":"","category":"section"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"The log-rank test [4] is a non-parametric test to compare the survival distributions of two or more groups. It can be stratified to account for baseline differences.","category":"page"},{"location":"nonparametric/logranktest/#Theory","page":"Log-Rank Test","title":"Theory","text":"","category":"section"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"Suppose we have G groups. At each event time t_j:","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"d_gj: number of events in group g at t_j\nY_gj: number at risk in group g just before t_j\nd_j = sum_g d_gj: total events at t_j\nY_j = sum_g Y_gj: total at risk at t_j","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"The expected number of events in group g at t_j under the null hypothesis is:","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"E_gj = Y_gj fracd_jY_j","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"The log-rank test statistic is:","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"Z_g = sum_j (d_gj - E_gj)","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"For two groups, the test statistic is:","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"Z = fracleftsum_j (d_1j - E_1j)right^2sum_j V_1j","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"where","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"V_1j = fracY_1j Y_2j d_j (Y_j - d_j)Y_j^2 (Y_j - 1)","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"Under the null hypothesis, Z is approximately chi-squared distributed with G-1 degrees of freedom.","category":"page"},{"location":"nonparametric/logranktest/#Stratified-Log-Rank-Test","page":"Log-Rank Test","title":"Stratified Log-Rank Test","text":"","category":"section"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"If there are strata, the test statistic and variance are summed over strata.","category":"page"},{"location":"nonparametric/logranktest/#Usage","page":"Log-Rank Test","title":"Usage","text":"","category":"section"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"using SurvivalModels\n\nT = [1, 2, 3, 4, 1, 2, 3, 4]\nΔ = [1, 1, 1, 1, 1, 1, 1, 1]\ngroup = [1, 1, 2, 2, 1, 1, 2, 2]\nstrata = [1, 1, 1, 1, 2, 2, 2, 2]\nlrt = LogRankTest(T, Δ, group, strata)","category":"page"},{"location":"nonparametric/logranktest/#Fields","page":"Log-Rank Test","title":"Fields","text":"","category":"section"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"stat: Chi-square test statistic.\ndf: Degrees of freedom.\npval: P-value of the test.","category":"page"},{"location":"nonparametric/logranktest/#Formula-interface","page":"Log-Rank Test","title":"Formula interface","text":"","category":"section"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"using DataFrames\ndf = DataFrame(time=T, status=Δ, group=group, strata=strata)\nlrt2 = fit(LogRankTest, @formula(Surv(time, status) ~ Strata(strata) + group), df)","category":"page"},{"location":"nonparametric/logranktest/#References","page":"Log-Rank Test","title":"References","text":"","category":"section"},{"location":"nonparametric/logranktest/#SurvivalModels.LogRankTest","page":"Log-Rank Test","title":"SurvivalModels.LogRankTest","text":"LogRankTest(T, Δ, group, strata)\nfit(LogRankTest, @formula(Surv(T, Δ) ~ gr), data = ...)\nfit(LogRankTest, @formula(Surv(T, Δ) ~ Strata(st) + gr), data = ...)\n\nPerforms the stratified log-rank test for comparing survival distributions across groups.\n\nArguments\n\nT: Vector of observed times.\nΔ: Vector of event indicators (1 = event, 0 = censored).\ngroup: Vector indicating group membership (e.g., treatment arm).\nstrata: Vector indicating strata membership (e.g., baseline strata).\ngr and st are the variables in the DataFrame defining the groups and strata for the fit interface.\n\nReturns\n\nA LogRankTest object with the following fields:\n\nstat: Chi-square test statistic.\ndf: Degrees of freedom (number of groups minus 1).\npval: P-value of the test.\n\nNotes\n\nImplements the stratified log-rank test by aggregating test statistics and variances over strata.\nSuitable for right-censored survival data with stratification.\n\n\n\n\n\n","category":"type"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"N. Mantel. Evaluation of survival data and two new rank order statistics arising in its consideration. Cancer chemotherapy reports 50, 163–170 (1966).\n\n\n\n","category":"page"},{"location":"nonparametric/kaplanmeier/#Kaplan-Meier-Estimator","page":"Kaplan-Meier","title":"Kaplan-Meier Estimator","text":"","category":"section"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"The Kaplan-Meier estimator[2] is a non-parametric statistic used to estimate the survival function from lifetime data, especially when data are censored. The Greenwood formula[3] is used for variance estimation.","category":"page"},{"location":"nonparametric/kaplanmeier/#Theory","page":"Kaplan-Meier","title":"Theory","text":"","category":"section"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"Suppose we observe n individuals, with observed times T_1 T_2 ldots T_n and event indicators Delta_1 Delta_2 ldots Delta_n (Delta_i = 1 if the event occurred, 0 if censored).","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"Let t_1  t_2  cdots  t_k be the ordered unique event times.","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"d_j: number of events at time t_j\nY_j: number of individuals at risk just before t_j","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"The Kaplan-Meier estimator of the survival function S(t) is:","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"hatS(t) = prod_t_j leq t left(1 - fracd_jY_jright)","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"This product runs over all event times t_j less than or equal to t.","category":"page"},{"location":"nonparametric/kaplanmeier/#Greenwood's-Formula","page":"Kaplan-Meier","title":"Greenwood's Formula","text":"","category":"section"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"The Greenwood estimator for the variance of hatS(t) is:","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"widehatmathrmVarhatS(t) = hatS(t)^2 sum_t_j leq t fracd_jY_j (Y_j - d_j)","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"This allows for the construction of confidence intervals for the survival curve.","category":"page"},{"location":"nonparametric/kaplanmeier/#Usage","page":"Kaplan-Meier","title":"Usage","text":"","category":"section"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"using SurvivalModels\n\nT = [2, 3, 4, 5, 8]\nΔ = [1, 1, 0, 1, 0]\nkm = KaplanMeier(T, Δ)","category":"page"},{"location":"nonparametric/kaplanmeier/#Fields","page":"Kaplan-Meier","title":"Fields","text":"","category":"section"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"t: Sorted unique event times.\n∂N: Number of uncensored deaths at each time point.\nY: Number of individuals at risk at each time point.\n∂Λ: Increments of cumulative hazard.\n∂σ: Greenwood variance increments.","category":"page"},{"location":"nonparametric/kaplanmeier/#Formula-interface","page":"Kaplan-Meier","title":"Formula interface","text":"","category":"section"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"using DataFrames\ndf = DataFrame(time=T, status=Δ)\nkm2 = fit(KaplanMeier, @formula(Surv(time, status) ~ 1), df)","category":"page"},{"location":"nonparametric/kaplanmeier/#Survival-and-variance-estimates","page":"Kaplan-Meier","title":"Survival and variance estimates","text":"","category":"section"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"using SurvivalModels: greenwood\nŜ = km(5.0)  # Survival probability at time 5\nv̂ = greenwood(km, 5.0)  # Greenwood variance at time 5\nŜ, v̂","category":"page"},{"location":"nonparametric/kaplanmeier/#Confidence-Intervals","page":"Kaplan-Meier","title":"Confidence Intervals","text":"","category":"section"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"A (1-alpha) times 100 confidence interval for S(t) can be constructed using the log-minus-log transformation:","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"log(-log hatS(t)) pm z_1-alpha2 frac1log hatS(t) sqrtwidehatmathrmVarhatS(t)","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"using SurvivalModels\n\nT = [2, 3, 4, 5, 8]\nΔ = [1, 1, 0, 1, 0]\nkm = KaplanMeier(T, Δ)\n\n# Compute confidence intervals at each event time (default 95%)\nci = confint(km)\nfirst(ci, 5)  # show the first 5 rows","category":"page"},{"location":"nonparametric/kaplanmeier/#References","page":"Kaplan-Meier","title":"References","text":"","category":"section"},{"location":"nonparametric/kaplanmeier/#SurvivalModels.KaplanMeier","page":"Kaplan-Meier","title":"SurvivalModels.KaplanMeier","text":"KaplanMeier(T, Δ)\nfit(KaplanMeier, @formula(Surv(T, Δ) ~ 1), df)\n\nEfficient Kaplan-Meier estimator.\n\nMathematical Description\n\nSuppose we observe n individuals, with observed times T_1 T_2 ldots T_n and event indicators Delta_1 Delta_2 ldots Delta_n (Delta_i = 1 if the event occurred, 0 if censored).\n\nLet t_1  t_2  cdots  t_k be the ordered unique event times.\n\nd_j: number of events at time t_j\nY_j: number of individuals at risk just before t_j\n\nThe Kaplan-Meier estimator of the survival function S(t) is:\n\nhatS(t) = prod_t_j leq t left(1 - fracd_jY_jright)\n\nThis product runs over all event times t_j less than or equal to t.\n\nThe Greenwood estimator for the variance of hatS(t) is:\n\nwidehatmathrmVarhatS(t) = hatS(t)^2 sum_t_j leq t fracd_jY_j (Y_j - d_j)\n\nArguments\n\nT: Vector of event or censoring times.\nΔ: Event indicator vector (1 if event, 0 if censored).\n\nStores\n\nt: Sorted unique event times.\n∂N: Number of uncensored deaths at each time point.\nY: Number of at risk individuals at each time point.\n∂Λ: Increments of cumulative hazard.\n∂σ: Greenwood variance increments.\n\nExample: Direct usage\n\nusing SurvivalModels\nT = [2, 3, 4, 5, 8]\nΔ = [1, 1, 0, 1, 0]\nkm = KaplanMeier(T, Δ)\n\nExample: Using the fit() interface\n\nusing SurvivalModels, DataFrames, StatsModels\ndf = DataFrame(time=T, status=Δ)\nkm2 = fit(KaplanMeier, @formula(Surv(time, status) ~ 1), df)\n\n\n\n\n\n","category":"type"},{"location":"nonparametric/kaplanmeier/#SurvivalModels.greenwood","page":"Kaplan-Meier","title":"SurvivalModels.greenwood","text":"greenwood(S::KaplanMeier, t)\n\nCompute the Greenwood variance estimate for the Kaplan-Meier survival estimator at time t.\n\nThe Greenwood formula provides an estimate of the variance of the Kaplan-Meier survival function at a given time point. For a fitted Kaplan-Meier object S, the variance at time t is:\n\n```math \\widehat{\\mathrm{Var}}[\\hat{S}(t)] = \\hat{S}(t)^2 \\sum{tj < t} \\frac{dj}{Yj (Yj - dj)}\n\n\n\n\n\n","category":"function"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"E. L. Kaplan and P. Meier. Nonparametric estimation from incomplete observations. Journal of the American statistical association 53, 457–481 (1958).\n\n\n\nM. Greenwood. The natural duration of cancer. Reports on Public Health and Medical Subjects 33, 1–26 (1926).\n\n\n\n","category":"page"},{"location":"semiparametric/cox/#Cox-models","page":"Cox","title":"Cox models","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"one ref: [1].","category":"page"},{"location":"semiparametric/cox/#Theory","page":"Cox","title":"Theory","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The Cox Proportional Hazards Model is a semi-parametric model used to analyze time-to-event data. It models the relationship between the survival time of an individual and a set of covariates. It is defined by the hazard function:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"h(t  mathbfX) = h_0(t) exp(mathbfX^Tmathbfbeta)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"where: h_0(t) is the baseline hazard function,  mathbfX is the covariate vector,  mathbfbeta is the vector of regression coefficients.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The partial-likelihood function for the Cox model is given by:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"L(mathbfbeta) = prod_j=1^k fracprod_ Delta_i=1 exp(mathbfX_i^Tmathbfbeta)left( sum_l in R_j exp(mathbfX_l^Tmathbfbeta) right)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"Our goal is to maximize the log-partial-likelihood or, equivalently, to minimize its negative, which we define as our loss function:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"\ntextLoss(mathbfbeta) = - log L(mathbfbeta) = - sum_j=1^k left( sum mathbfX_i^Tmathbfbeta - log left( sum_l in R_j exp(mathbfX_l^Tmathbfbeta) right) right)\n","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The loss function is coded as follows: ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"function loss(beta, M::Cox)\n    η = M.X*beta\n    return dot(M.Δ, log.((M.T .<= M.T') * exp.(η)) .- η)\nend","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"We differentiate once and obtain the gradient:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"\nfracpartialpartial beta_k textLoss(mathbfbeta) = - sum_i=1^n left( X_ik - fracsum_j in R_i exp(mathbfbeta^TmathbfX_j) X_jksum_j in R_i exp(mathbfbeta^TmathbfX_j) right)\n","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"And the Hesian matrix: ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"\nfracpartial^2partial beta_k partial beta_l textLoss(mathbfbeta) = sum_i=1^n left fracsum_j in R_i exp(mathbfbeta^TmathbfX_j) X_jkX_jlsum_j in R_i exp(mathbfbeta^TmathbfX_j) - fracleft( sum_j in R_i exp(mathbfbeta^TmathbfX_j) X_jk right) left( sum_j in R_i exp(mathbfbeta^TmathbfX_j) X_jl right)left( sum_j in R_i exp(mathbfbeta^TmathbfX_j) right)^2 right\n","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The information matrix is defined as the negative of the Hessian matrix of the log-likelihood function, evaluated at the point of the estimated coefficients. ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"\nI(hatboldsymbolbeta) = -H(hatboldsymbolbeta)\n","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"But, in the earlier formula, mathbfH_textLoss​ was for Loss(β), which is -log L(β) mathbfH_textLoss = - mathbfH_textlog-likelihood. Therefore, the observed Information Matrix is equal to mathbfH_textLoss itself.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The variance (and covariance) of our estimators hatboldsymbolbeta are obtained by inverting the observed information matrix.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"textVar(hatboldsymbolbeta) = I(hatboldsymbolbeta)^-1","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"This final matrix contains:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"On its diagonal: the variances of each coefficient (textVar(hatbeta_1), textVar(hatbeta_2), ...).\nOff-diagonal: the covariances between pairs of coefficients.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The standard error for a specific coefficient (hatbeta_k) is the square root of its variance.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"SE(hatbeta_k) = sqrttextVar(hatbeta_k)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"To determine if a variable has a statistically significant effect, a Wald test is performed. A z-score is calculated: z = fractextCoefficienttextErreur Type = frachatbetaSE(hatbeta)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"This z-score is then compared to a normal distribution to obtain a p-value. A low p-value (typically < 0.05) suggests that the coefficient is significantly different from zero.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The p-value for each coefficient is calculated by comparing its z-score to a standard normal distribution. This p-value indicates the probability of observing a z-score as extreme as, or more extreme than, the one calculated, assuming the null hypothesis (that the coefficient is zero) is true.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The standard error allows for the construction of a confidence interval (CI) around the coefficient, which provides a range of plausible values for the true coefficient.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The general formula for a (1 - alpha) times 100 confidence interval is:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"textIC pour  hatbeta = hatbeta pm z_alpha2 times SE(hatbeta)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"Let us see for example the output on the colon dataset: ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"using SurvivalModels\nusing RDatasets\n\n# ovarian = dataset(\"survival\", \"ovarian\")\n# ovarian.FUTime = Float64.(ovarian.FUTime)\n# ovarian.FUStat = Bool.(ovarian.FUStat)\n# model = fit(Cox, @formula(Surv(FUTime, FUStat) ~ Age + ECOG_PS), ovarian)\n\ncolon = dataset(\"survival\", \"colon\")\ncolon.Time = Float64.(colon.Time)\ncolon.Status = Bool.(colon.Status)\nmodel_colon = fit(Cox, @formula(Surv(Time, Status) ~ Age + Rx), colon)\n","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The outputed datafrae contains collumns with respectively the name of the predictor, the obtained coefficients, its standard error, the associated p-value and the test statistic z as just described. ","category":"page"},{"location":"semiparametric/cox/#SurvivalModels.Cox","page":"Cox","title":"SurvivalModels.Cox","text":"StatsBase.fit(Cox, @formula(Surv(T,Δ)~predictors), dataset)\n\narguments: \n- T: The Cox model type to fit (CoxV3)\n- formula: A StatsModels.FormulaTerm specifying the survival model\n- df: A DataFrame containing the variables specified in the formula\n\nreturns: \n- predictor: A Vector{String} containing the names of the predictor variables included in the model\n- beta: A Vector{Float64} containing the estimated regression coefficients (β​) for each predictor\n- se: A Vector{Float64} containing the standard errors of the estimated regression coefficients\n- loglikelihood: A Vector{Float64} containing the log-likelihood of the fitted model. This value is repeated for each predictor row \n\n- coef: A vector of the estimated coefficients\n- formula: The applied formula\n\nExample: ovarian = dataset(\"survival\", \"ovarian\") ovarian.FUTime = Float64.(ovarian.FUTime) (Time column needs to be Float64 type) ovarian.FUStat = Bool.(ovarian.FUStat) (Status column needs to be Bool type) model = fit(Cox, @formula(Surv(FUTime, FUStat) ~ Age + ECOG_PS), ovarian)\n\nTypes: \n\nCox : the base abstract type\nCoxGrad<:Cox : abstract type for Cox models that are solved using gradient-based optimization\nCoxLLH<:CoxGrad : abstract type for Cox models that are solved by optimizing the log-likelihood\n\n\n\n\n\n","category":"type"},{"location":"semiparametric/cox/#Different-versions-of-the-optimisation-routine","page":"Cox","title":"Different versions of the optimisation routine","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"To implement the Cox proportional hazards model, different versions were coded, using different methods. The final goal is to compare these versions and choose the most efficient one: the fastest and the closest to the true values of the coefficients. ","category":"page"},{"location":"semiparametric/cox/#V0","page":"Cox","title":"V0","text":"","category":"section"},{"location":"semiparametric/cox/#SurvivalModels.CoxV0","page":"Cox","title":"SurvivalModels.CoxV0","text":"CoxVO(T, Δ, X)\nfit(CoxV0, @formula(Surv(T,Δ)~X), data = ...)\n\nAn implementation of the Cox proportional hazards model that minimizes the negative partial log-likelihood function (cox_nllh). This version uses the Nelder-Mead method, a derivative-free optimization algorithm. \n\nFields:      - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features     - T::Vector{Float64}: The observed times, sorted in ascending order      - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)\n\n\n\n\n\n","category":"type"},{"location":"semiparametric/cox/#V1:-Implementation-using-the-'Optimization.jl'-Julia-package","page":"Cox","title":"V1: Implementation using the 'Optimization.jl' Julia package","text":"","category":"section"},{"location":"semiparametric/cox/#SurvivalModels.CoxV1","page":"Cox","title":"SurvivalModels.CoxV1","text":"CoxV1(T, Δ, X)\nfit(CoxV1, @formula(Surv(T,Δ)~X), data = ...)\n\nThe first implementation of the Cox proportional hazards model uses optimization libraries (Optimization.jl, Optim.jl) for coefficient estimation. It uses the BFGS algorithm to minimize the negative partial log-likelihood. \n\nFields:      - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features.     - T::Vector{Float64}: The observed times, sorted in ascending order     - Δ::Vector{Int64}: The event indicator vector (true for event, false for censoring)\n\n\n\n\n\n","category":"type"},{"location":"semiparametric/cox/#V2:-Implementation-using-the-gradient-and-the-Hessian-matrix","page":"Cox","title":"V2: Implementation using the gradient and the Hessian matrix","text":"","category":"section"},{"location":"semiparametric/cox/#SurvivalModels.CoxV2","page":"Cox","title":"SurvivalModels.CoxV2","text":"CoxV2(T, Δ, X)\nfit(CoxV2, @formula(Surv(T,Δ)~X), data = ...)\n\nThe second implementation of the Cox proportional hazards model uses a Newton-Raphson-like iterative update that directly calculates and utilizes the gradient and Hessian matrix. This version is updating coefficients via the update! function.\n\nFields:     - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features     - T::Vector{Float64}: The observed times, sorted in ascending order     - Δ::Vector{Int64}: The event indicator vector (true for event, false for censoring)     - R::BitMatrix: A boolean risk matrix, where 'R[i,j]' is 'true' if individual 'j' is at risk at time 'T[i]'\n\n\n\n\n\n","category":"type"},{"location":"semiparametric/cox/#V3:-Improved-version-of-V2-(much-faster)-because-non-allocative.","page":"Cox","title":"V3: Improved version of V2 (much faster) because non-allocative.","text":"","category":"section"},{"location":"semiparametric/cox/#SurvivalModels.CoxV3","page":"Cox","title":"SurvivalModels.CoxV3","text":"CoxV3(T, Δ, X)\nfit(CoxV3, @formula(Surv(T,Δ)~X), data = ...)\nfit(Cox, @formula(Surv(T,Δ)~X), data = ...)\n\nThe third implementation of the Cox proportional hazards model represents a highly optimized and significantly faster iteration compared to previous implementation, CoxV2.\n\nThis is the default implementation called when you ask for a Cox model. \n\nFields:     - Xᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)     - sX::Vector{Float64}: Sum of X' multiplied by Δ     - T::Vector{Float64}: The observed times sorted in descending order     - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)     - loss::Vector{Float64}: Stores the current negative partial log-likelihood value     - G::Vector{Float64}: Stores the gradient vector       - H::Matrix{Float64}: Stores the Hessian matrix      - S₁::Vector{Float64}: Sum of rⱼxₖⱼ     - S₂::Matrix{Float64}: Sum of rⱼxₖⱼ * xⱼ     - μ::Vector{Float64}: Updates the gradient and Hessian     - η::Vector{Float64}: ηi = Xiβ     - r::Vector{Float64}: ri = exp(ηi)     - R::Vector{UnitRange{Int64}}: A vector of the risk ranges for each output time.\n\n\n\n\n\n","category":"type"},{"location":"semiparametric/cox/#V4:-Majoration-of-the-Hessian-matrix-by-a-universal-bound.","page":"Cox","title":"V4: Majoration of the Hessian matrix by a universal bound.","text":"","category":"section"},{"location":"semiparametric/cox/#SurvivalModels.CoxV4","page":"Cox","title":"SurvivalModels.CoxV4","text":"CoxV4(T, Δ, X)\nfit(CoxV4, @formula(Surv(T,Δ)~X), data = ...)\n\nThe fourth implementation of the Cox proportional hazards model uses Hessian approximation based on a pre-calculated estimation. This version was created for when it might be difficult to work with full Hessian , offering faster iterations by using a Hessian approximation.\n\nFields:     - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features     - T::Vector{Float64}: The observed times sorted in ascending order     - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)     - sX::Vector{Float64}: Sum of X' multiplied by Δ     - G::Vector{Float64}: Stores the gradient vector     - η::Vector{Float64}: ηi = Xiβ     - A::Vector{Float64}: Ai = exp(ηi)     - B::Vector{Float64}: Stores the majoration elements of the Hessian matrix     - C::Vector{Float64}: Used in the mkA! function     - K::Vector{Int64}: Number of events at each unique observed event time     - loss::Vector{Float64}: Stores the current negative partial log-likelihood value, used in CoxLLH getβ\n\n\n\n\n\n","category":"type"},{"location":"semiparametric/cox/#V5","page":"Cox","title":"V5","text":"","category":"section"},{"location":"semiparametric/cox/#SurvivalModels.CoxV5","page":"Cox","title":"SurvivalModels.CoxV5","text":"CoxV5(T, Δ, X)\nfit(CoxV5, @formula(Surv(T,Δ)~X), data = ...)\n\nThe fifth implementation of the Cox proportional hazards model uses a pre-calculated Hessian approximation for faster iterations, like CoxV4. Its approach is similar to CoxV3.\n\nFields:     - Xᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)     - sX::Vector{Float64}: Sum of X' multiplied by Δ     - T::Vector{Float64}: The observed times sorted in descending order     - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)     - loss::Vector{Float64}: Stores the current negative partial log-likelihood value     - G::Vector{Float64}: Stores the gradient vector.     - S₁::Vector{Float64}:  Sum of rⱼxₖⱼ     - μ::Vector{Float64}: Currently unused in update! function     - η::Vector{Float64}: ηi = Xiβ     - r::Vector{Float64}: ri = exp(ηi)     - R::Vector{UnitRange{Int64}}:     - B::Vector{Float64}: Stores the majoration elements of the Hessian matrix\n\n\n\n\n\n","category":"type"},{"location":"semiparametric/cox/#Comparison-of-the-different-methods-speed","page":"Cox","title":"Comparison of the different methods speed","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"We propose to compare the different methods on simulated data, with varying number of lines and columns, to verify empirically the theoretical complexity of the different methods.  We will then compare the results with Julia's and R's existing Cox implementation.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"using SurvivalModels, Plots, Random, Distributions, StatsBase, LinearAlgebra, DataFrames, RCall, Survival\n\nusing SurvivalModels: getβ, CoxV0, CoxV1, CoxV2, CoxV3, CoxV4, CoxV5","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"struct CoxVJ\n    T::Vector{Float64}\n    Δ::Vector{Bool}\n    X::Matrix{Float64}\n    function CoxVJ(T,Δ,X)\n        new(T,Bool.(Δ),X)\n    end\nend\n\nfunction SurvivalModels.getβ(M::CoxVJ)\n    return fit(Survival.CoxModel, M.X, Survival.EventTime.(M.T,M.Δ)).β\nend\n","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"R\"\"\"\nlibrary(survival)\n\"\"\"\n\nstruct CoxVR\n    df::DataFrame\n    function CoxVR(T,Δ,X)\n        df = DataFrame(X,:auto)\n        df.status = Δ\n        df.time = T\n        new(df)\n    end\nend\n\nfunction SurvivalModels.getβ(M::CoxVR)\n    df = M.df\n    @rput df\n    R\"\"\"\n    beta  <- coxph(Surv(time,status)~., data = df, ties=\"breslow\")$coefficients\n    \"\"\"\n    @rget beta\n    return beta\nend","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"# Creating a dictionary for all the models:\n# Label => (constructor, plotting color)\n\nconst design = Dict(\n\"V0\"=> (CoxV0, :blue),\n\"V1\"=> (CoxV1, :orange),\n\"V2\"=> (CoxV2, :brown),\n\"V3\"=> (CoxV3, :purple),\n\"V4\"=> (CoxV4, :green),\n\"V5\"=> (CoxV5, :yellow),\n\"VR\"=> (CoxVR, :red),\n\"VJ\"=> (CoxVJ, :black)\n);\n\n# Function to simulate data for different rows and column numbers (n max = 2000 et m max = 20):\nfunction simulate_survival_data(n, m; censor_rate = 0.2, β=randn(m))\n    Random.seed!(42)\n    X = hcat(\n        [randn(n)       for _ in 1:cld(m,3)]..., # about 1/3\n        [rand(n)        for _ in 1:cld(m,3)]..., # about 1/3\n        [exp.(randn(n)) for _ in 1:(m-2cld(m,3))]... # the rest. \n    )\n    η = X * β\n    λ₀ = 1 \n    U = rand(n)\n    O = -log.(U) ./ (λ₀ .* exp.(η))\n    lc = quantile(O, 1 - censor_rate)\n    C = rand(Exponential(lc), n)\n    T = min.(O, C)\n    Δ = Bool.(T .<= C)\n    return (T, Δ, X)\nend\n\n# Run the models and get the running time, the β coefficients and the difference between the true β and the obtained ones: \nfunction run_models() \n    Ns = (500, 1000, 2000) \n    Ms = (10, 20) \n    true_betas = randn(maximum(Ms))\n    df = []\n    for n in Ns, m in Ms\n        if (n == 2000) | (m == 20) # Only if they end up in the graphs.\n            data = simulate_survival_data(n,m, β = true_betas[1:m])\n            for (name, (constructor, _)) in design\n                display((n,m,name))\n                model = constructor(data...)\n                beta = getβ(model)\n                time = @elapsed getβ(model)\n                push!(df, (\n                    n = n, \n                    m = m, \n                    name = name, \n                    time = time,\n                    beta = beta,\n                    diff_to_truth = sqrt(sum((beta .- true_betas[1:m]).^2)/sum(true_betas[1:m].^2)),\n                ))\n            end\n        end\n    end\n    df = DataFrame(df)\n    sort!(df, :name)\n    return df\nend\n\n# Plot the results, starting with the time: \nfunction timing_graph(df)\n    group1 = groupby(filter(r -> r.m==20, df), :name)\n    p1 = plot(; xlabel = \"Number of observations (n)\",\n        ylabel = \"Time (in seconds)\",\n        yscale= :log10,\n        xscale= :log10,\n        title = \"For m=20 covs., varying n\",\n        legend = :bottomright,\n        lw = 1);\n    for g in group1\n        plot!(p1, g.n, g.time, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n    end\n    group2 = groupby(filter(r -> r.n==2000, df), :name)\n        p2 = plot(; xlabel = \"Number of covariates (m)\",\n            ylabel = \"Temps (ms)\",\n            yscale= :log10,\n            xscale= :log10,\n            title = \"For n=2000 obs., varying m\",\n            legend = :bottomright,\n            lw = 1);\n        for g in group2\n            plot!(p2, g.m, g.time, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n        end\n        p = plot(p1,p2, size=(1200,600), plot_title = \"Runtime (logscale) of the various implementations\")\n        return p\nend","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"x=1\n# df = run_models()\n# timing_graph(df)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"comments on the graph. ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"A zoom on our implementation vs Survival.jl vs R::survival: ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"x=1\n# timing_graph(filter(r -> r.name ∈ (\"V3\", \"VJ\", \"VR\"), df))","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"So we are about x10 faster than the reference implmentation of R (and than the previous Julia attemps) on this example. ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"function beta_correctness_graphs(df; ref=\"VJ\")\n    \n    reflines = filter(r -> r.name == ref, df)\n    rename!(reflines, :beta => :refbeta)\n    select!(reflines, Not([:name, :time, :diff_to_truth]))\n    otherlines = filter(r -> r.name != ref, df)\n    rez = leftjoin(otherlines, reflines, on=[:n,:m])\n    percent(x,y) = sqrt(sum((x .- y).^2)/sum(y .^2))\n    rez.error = percent.(rez.beta, rez.refbeta)\n    select!(rez, [:n,:m,:name,:error])\n    rez = filter!(r -> !isnan(r.error), rez)\n    \n    group1 = groupby(filter(r -> r.m==20, rez), :name)\n    p1 = plot(; xlabel = \"Number of observations (n)\",\n                ylabel = \"L2dist to $ref's β\",\n                yscale=:log10,\n                xscale= :log10,\n                title = \"m=20, varying n\",\n                legend = :bottomright,\n                lw = 1);\n    for g in group1\n        plot!(p1, g.n, g.error, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n    end\n\n    group2 = groupby(filter(r -> r.n==2000, rez), :name)\n    p2 = plot(; xlabel = \"Nomber of covariates (m)\",\n                ylabel = \"L2Dist to $ref's β\",\n                yscale=:log10,\n                xscale= :log10,\n                title = \"n=2000, varying m\",\n                legend = :bottomright,\n                lw = 1);\n    for g in group2\n        plot!(p2, g.m, g.error, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n    end\n    p = plot(p1,p2, size=(1200,600), plot_title=\"β-correctness w.r.t. $ref's version.\")\n    return p\nend\n\n# beta_correctness_graphs(df)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"function beta_wrt_truth(df)\n    group1 = groupby(filter(r -> r.m==20, df), :name)\n    p1 = plot(; xlabel = \"Number of observations (n)\",\n                ylabel = \"L2dist to the truth\",\n                yscale=:log10,\n                xscale= :log10,\n                title = \"m=20, varying n\",\n                legend = :bottomright,\n                lw = 1);\n    for g in group1\n        plot!(p1, g.n, g.diff_to_truth, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n    end\n\n    group2 = groupby(filter(r -> r.n==2000, df), :name)\n    p2 = plot(; xlabel = \"Nomber of covariates (m)\",\n                ylabel = \"L2Dist to the truth\",\n                yscale=:log10,\n                xscale= :log10,\n                title = \"n=2000, varying m\",\n                legend = :bottomright,\n                lw = 1);\n    for g in group2\n        plot!(p2, g.m, g.diff_to_truth, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n    end\n    p = plot(p1,p2, size=(1200,600), plot_title=\"β-correctness w.r.t. the truth.\")\n    return p\nend   \n\n# beta_wrt_truth(df)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"D. R. Cox. Regression models and life-tables. Journal of the Royal Statistical Society: Series B (Methodological) 34, 187–202 (1972).\n\n\n\n","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SurvivalModels.jl package, part of the JuliaSurv ecosystem, provides the necessary tools to perform estimation and analysis of survival data. In contains three categories of models: Non-parametric ones, semi-parametric ones, and fully parametric models. It also contains tests of hypothesis and other features. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The SurvivalModels.jl package is part of the JuliaSurv ecosystem around survival analysis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for [SurvivalModels].","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this documentation, we can cite stuff from the references.bib file like that : [1]. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation shall cover all the content of the package, which is not the case yet. ","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Non-parametric modelling: \nKaplan-Meier\nLog-rank tests, including stratified versions \nSemi-Parametric modelling: \nCox\nParametric modelling: \nGeneral Hazard models (still WIP: See PR #4)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is not yet available on Julia's general registry, and thus can be installed through the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"https://github.com/JuliaSurv/SurvivalModels.jl.git\")","category":"page"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"D. R. Cox. Regression models and life-tables. Journal of the Royal Statistical Society: Series B (Methodological) 34, 187–202 (1972).\n\n\n\n","category":"page"}]
}
