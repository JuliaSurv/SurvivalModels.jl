var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/#SurvivalModels.Cox-references","page":"References","title":"SurvivalModels.Cox","text":"StatsBase.fit(Cox, @formula(Surv(T,Δ)~predictors), dataset)\n\narguments: \n- T: The Cox model type to fit (CoxV3)\n- formula: A StatsModels.FormulaTerm specifying the survival model\n- df: A DataFrame containing the variables specified in the formula\n\nreturns: \n- predictor: A Vector{String} containing the names of the predictor variables included in the model\n- beta: A Vector{Float64} containing the estimated regression coefficients (β​) for each predictor\n- se: A Vector{Float64} containing the standard errors of the estimated regression coefficients\n- loglikelihood: A Vector{Float64} containing the log-likelihood of the fitted model. This value is repeated for each predictor row \n\n- coef: A vector of the estimated coefficients\n- formula: The applied formula\n\nExample: ovarian = dataset(\"survival\", \"ovarian\") ovarian.FUTime = Float64.(ovarian.FUTime) (Time column needs to be Float64 type) ovarian.FUStat = Bool.(ovarian.FUStat) (Status column needs to be Bool type) model = fit(Cox, @formula(Surv(FUTime, FUStat) ~ Age + ECOG_PS), ovarian)\n\nTypes: \n\nCox : the base abstract type\nCoxGrad<:Cox : abstract type for Cox models that are solved using gradient-based optimization\nCoxLLH<:CoxGrad : abstract type for Cox models that are solved by optimizing the log-likelihood\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV0-references","page":"References","title":"SurvivalModels.CoxV0","text":"CoxVO(T, Δ, X)\nfit(CoxV0, @formula(Surv(T,Δ)~X), data = ...)\n\nAn implementation of the Cox proportional hazards model that minimizes the negative partial log-likelihood function (cox_nllh). This version uses the Nelder-Mead method, a derivative-free optimization algorithm. \n\nFields:      - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features     - T::Vector{Float64}: The observed times, sorted in ascending order      - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV1-references","page":"References","title":"SurvivalModels.CoxV1","text":"CoxV1(T, Δ, X)\nfit(CoxV1, @formula(Surv(T,Δ)~X), data = ...)\n\nThe first implementation of the Cox proportional hazards model uses optimization libraries (Optimization.jl, Optim.jl) for coefficient estimation. It uses the BFGS algorithm to minimize the negative partial log-likelihood. \n\nFields:      - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features.     - T::Vector{Float64}: The observed times, sorted in ascending order     - Δ::Vector{Int64}: The event indicator vector (true for event, false for censoring)\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV2-references","page":"References","title":"SurvivalModels.CoxV2","text":"CoxV2(T, Δ, X)\nfit(CoxV2, @formula(Surv(T,Δ)~X), data = ...)\n\nThe second implementation of the Cox proportional hazards model uses a Newton-Raphson-like iterative update that directly calculates and utilizes the gradient and Hessian matrix. This version is updating coefficients via the update! function.\n\nFields:     - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features     - T::Vector{Float64}: The observed times, sorted in ascending order     - Δ::Vector{Int64}: The event indicator vector (true for event, false for censoring)     - R::BitMatrix: A boolean risk matrix, where 'R[i,j]' is 'true' if individual 'j' is at risk at time 'T[i]'\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV3-references","page":"References","title":"SurvivalModels.CoxV3","text":"CoxV3(T, Δ, X)\nfit(CoxV3, @formula(Surv(T,Δ)~X), data = ...)\nfit(Cox, @formula(Surv(T,Δ)~X), data = ...)\n\nThe third implementation of the Cox proportional hazards model represents a highly optimized and significantly faster iteration compared to previous implementation, CoxV2.\n\nThis is the default implementation called when you ask for a Cox model. \n\nFields:     - Xᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)     - sX::Vector{Float64}: Sum of X' multiplied by Δ     - T::Vector{Float64}: The observed times sorted in descending order     - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)     - loss::Vector{Float64}: Stores the current negative partial log-likelihood value     - G::Vector{Float64}: Stores the gradient vector       - H::Matrix{Float64}: Stores the Hessian matrix      - S₁::Vector{Float64}: Sum of rⱼxₖⱼ     - S₂::Matrix{Float64}: Sum of rⱼxₖⱼ * xⱼ     - μ::Vector{Float64}: Updates the gradient and Hessian     - η::Vector{Float64}: ηi = Xiβ     - r::Vector{Float64}: ri = exp(ηi)     - R::Vector{UnitRange{Int64}}: A vector of the risk ranges for each output time.\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV4-references","page":"References","title":"SurvivalModels.CoxV4","text":"CoxV4(T, Δ, X)\nfit(CoxV4, @formula(Surv(T,Δ)~X), data = ...)\n\nThe fourth implementation of the Cox proportional hazards model uses Hessian approximation based on a pre-calculated estimation. This version was created for when it might be difficult to work with full Hessian , offering faster iterations by using a Hessian approximation.\n\nFields:     - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features     - T::Vector{Float64}: The observed times sorted in ascending order     - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)     - sX::Vector{Float64}: Sum of X' multiplied by Δ     - G::Vector{Float64}: Stores the gradient vector     - η::Vector{Float64}: ηi = Xiβ     - A::Vector{Float64}: Ai = exp(ηi)     - B::Vector{Float64}: Stores the majoration elements of the Hessian matrix     - C::Vector{Float64}: Used in the mkA! function     - K::Vector{Int64}: Number of events at each unique observed event time     - loss::Vector{Float64}: Stores the current negative partial log-likelihood value, used in CoxLLH getβ\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV5-references","page":"References","title":"SurvivalModels.CoxV5","text":"CoxV5(T, Δ, X)\nfit(CoxV5, @formula(Surv(T,Δ)~X), data = ...)\n\nThe fifth implementation of the Cox proportional hazards model uses a pre-calculated Hessian approximation for faster iterations, like CoxV4. Its approach is similar to CoxV3.\n\nFields:     - Xᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)     - sX::Vector{Float64}: Sum of X' multiplied by Δ     - T::Vector{Float64}: The observed times sorted in descending order     - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)     - loss::Vector{Float64}: Stores the current negative partial log-likelihood value     - G::Vector{Float64}: Stores the gradient vector.     - S₁::Vector{Float64}:  Sum of rⱼxₖⱼ     - μ::Vector{Float64}: Currently unused in update! function     - η::Vector{Float64}: ηi = Xiβ     - r::Vector{Float64}: ri = exp(ηi)     - R::Vector{UnitRange{Int64}}:     - B::Vector{Float64}: Stores the majoration elements of the Hessian matrix\n\n\n\n\n\n","category":"type"},{"location":"references/","page":"References","title":"References","text":"D. R. Cox. Regression models and life-tables. Journal of the Royal Statistical Society: Series B (Methodological) 34, 187–202 (1972).\n\n\n\n","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"cox/#Cox-models","page":"Cox models","title":"Cox models","text":"","category":"section"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"one ref: [1].","category":"page"},{"location":"cox/#Theory","page":"Cox models","title":"Theory","text":"","category":"section"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"The Cox Proportional Hazards Model is a semi-parametric model used to analyze time-to-event data. It models the relationship between the survival time of an individual and a set of covariates. It is defined by the hazard function:","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"h(t  mathbfX) = h_0(t) exp(mathbfX^Tmathbfbeta)","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"where: h_0(t) is the baseline hazard function,  mathbfX is the covariate vector,  mathbfbeta is the vector of regression coefficients.","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"The partial-likelihood function for the Cox model is given by:","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"L(mathbfbeta) = prod_j=1^k fracprod_ Delta_i=1 exp(mathbfX_i^Tmathbfbeta)left( sum_l in R_j exp(mathbfX_l^Tmathbfbeta) right)","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"Our goal is to maximize the log-partial-likelihood or, equivalently, to minimize its negative, which we define as our loss function:","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"\ntextLoss(mathbfbeta) = - log L(mathbfbeta) = - sum_j=1^k left( sum mathbfX_i^Tmathbfbeta - log left( sum_l in R_j exp(mathbfX_l^Tmathbfbeta) right) right)\n","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"The loss function is coded as follows: ","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"function loss(beta, M::Cox)\n    η = M.X*beta\n    return dot(M.Δ, log.((M.T .<= M.T') * exp.(η)) .- η)\nend","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"We differentiate once and obtain the gradient:","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"\nfracpartialpartial beta_k textLoss(mathbfbeta) = - sum_i=1^n left( X_ik - fracsum_j in R_i exp(mathbfbeta^TmathbfX_j) X_jksum_j in R_i exp(mathbfbeta^TmathbfX_j) right)\n","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"And the Hesian matrix: ","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"\nfracpartial^2partial beta_k partial beta_l textLoss(mathbfbeta) = sum_i=1^n left fracsum_j in R_i exp(mathbfbeta^TmathbfX_j) X_jkX_jlsum_j in R_i exp(mathbfbeta^TmathbfX_j) - fracleft( sum_j in R_i exp(mathbfbeta^TmathbfX_j) X_jk right) left( sum_j in R_i exp(mathbfbeta^TmathbfX_j) X_jl right)left( sum_j in R_i exp(mathbfbeta^TmathbfX_j) right)^2 right\n","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"The information matrix is defined as the negative of the Hessian matrix of the log-likelihood function, evaluated at the point of the estimated coefficients. ","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"\nI(hatboldsymbolbeta) = -H(hatboldsymbolbeta)\n","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"But, in the earlier formula, mathbfH_textLoss​ was for Loss(β), which is -log L(β) mathbfH_textLoss = - mathbfH_textlog-likelihood. Therefore, the observed Information Matrix is equal to mathbfH_textLoss itself.","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"The variance (and covariance) of our estimators hatboldsymbolbeta are obtained by inverting the observed information matrix.","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"textVar(hatboldsymbolbeta) = I(hatboldsymbolbeta)^-1","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"This final matrix contains:","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"On its diagonal: the variances of each coefficient (textVar(hatbeta_1), textVar(hatbeta_2), ...).\nOff-diagonal: the covariances between pairs of coefficients.","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"The standard error for a specific coefficient (hatbeta_k) is the square root of its variance.","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"SE(hatbeta_k) = sqrttextVar(hatbeta_k)","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"To determine if a variable has a statistically significant effect, a Wald test is performed. A z-score is calculated: z = fractextCoefficienttextErreur Type = frachatbetaSE(hatbeta)","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"This z-score is then compared to a normal distribution to obtain a p-value. A low p-value (typically < 0.05) suggests that the coefficient is significantly different from zero.","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"The p-value for each coefficient is calculated by comparing its z-score to a standard normal distribution. This p-value indicates the probability of observing a z-score as extreme as, or more extreme than, the one calculated, assuming the null hypothesis (that the coefficient is zero) is true.","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"The standard error allows for the construction of a confidence interval (CI) around the coefficient, which provides a range of plausible values for the true coefficient.","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"The general formula for a (1 - alpha) times 100 confidence interval is:","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"textIC pour  hatbeta = hatbeta pm z_alpha2 times SE(hatbeta)","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"Let us see for example the output on the colon dataset: ","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"using SurvivalModels\nusing RDatasets\n\n# ovarian = dataset(\"survival\", \"ovarian\")\n# ovarian.FUTime = Float64.(ovarian.FUTime)\n# ovarian.FUStat = Bool.(ovarian.FUStat)\n# model = fit(Cox, @formula(Surv(FUTime, FUStat) ~ Age + ECOG_PS), ovarian)\n\ncolon = dataset(\"survival\", \"colon\")\ncolon.Time = Float64.(colon.Time)\ncolon.Status = Bool.(colon.Status)\nmodel_colon = fit(Cox, @formula(Surv(Time, Status) ~ Age + Rx), colon)\n","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"The outputed datafrae contains collumns with respectively the name of the predictor, the obtained coefficients, its standard error, the associated p-value and the test statistic z as just described. ","category":"page"},{"location":"cox/#SurvivalModels.Cox","page":"Cox models","title":"SurvivalModels.Cox","text":"StatsBase.fit(Cox, @formula(Surv(T,Δ)~predictors), dataset)\n\narguments: \n- T: The Cox model type to fit (CoxV3)\n- formula: A StatsModels.FormulaTerm specifying the survival model\n- df: A DataFrame containing the variables specified in the formula\n\nreturns: \n- predictor: A Vector{String} containing the names of the predictor variables included in the model\n- beta: A Vector{Float64} containing the estimated regression coefficients (β​) for each predictor\n- se: A Vector{Float64} containing the standard errors of the estimated regression coefficients\n- loglikelihood: A Vector{Float64} containing the log-likelihood of the fitted model. This value is repeated for each predictor row \n\n- coef: A vector of the estimated coefficients\n- formula: The applied formula\n\nExample: ovarian = dataset(\"survival\", \"ovarian\") ovarian.FUTime = Float64.(ovarian.FUTime) (Time column needs to be Float64 type) ovarian.FUStat = Bool.(ovarian.FUStat) (Status column needs to be Bool type) model = fit(Cox, @formula(Surv(FUTime, FUStat) ~ Age + ECOG_PS), ovarian)\n\nTypes: \n\nCox : the base abstract type\nCoxGrad<:Cox : abstract type for Cox models that are solved using gradient-based optimization\nCoxLLH<:CoxGrad : abstract type for Cox models that are solved by optimizing the log-likelihood\n\n\n\n\n\n","category":"type"},{"location":"cox/#Different-versions-of-the-optimisation-routine","page":"Cox models","title":"Different versions of the optimisation routine","text":"","category":"section"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"To implement the Cox proportional hazards model, different versions were coded, using different methods. The final goal is to compare these versions and choose the most efficient one: the fastest and the closest to the true values of the coefficients. ","category":"page"},{"location":"cox/#V0","page":"Cox models","title":"V0","text":"","category":"section"},{"location":"cox/#SurvivalModels.CoxV0","page":"Cox models","title":"SurvivalModels.CoxV0","text":"CoxVO(T, Δ, X)\nfit(CoxV0, @formula(Surv(T,Δ)~X), data = ...)\n\nAn implementation of the Cox proportional hazards model that minimizes the negative partial log-likelihood function (cox_nllh). This version uses the Nelder-Mead method, a derivative-free optimization algorithm. \n\nFields:      - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features     - T::Vector{Float64}: The observed times, sorted in ascending order      - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)\n\n\n\n\n\n","category":"type"},{"location":"cox/#V1:-Implementation-using-the-'Optimization.jl'-Julia-package","page":"Cox models","title":"V1: Implementation using the 'Optimization.jl' Julia package","text":"","category":"section"},{"location":"cox/#SurvivalModels.CoxV1","page":"Cox models","title":"SurvivalModels.CoxV1","text":"CoxV1(T, Δ, X)\nfit(CoxV1, @formula(Surv(T,Δ)~X), data = ...)\n\nThe first implementation of the Cox proportional hazards model uses optimization libraries (Optimization.jl, Optim.jl) for coefficient estimation. It uses the BFGS algorithm to minimize the negative partial log-likelihood. \n\nFields:      - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features.     - T::Vector{Float64}: The observed times, sorted in ascending order     - Δ::Vector{Int64}: The event indicator vector (true for event, false for censoring)\n\n\n\n\n\n","category":"type"},{"location":"cox/#V2:-Implementation-using-the-gradient-and-the-Hessian-matrix","page":"Cox models","title":"V2: Implementation using the gradient and the Hessian matrix","text":"","category":"section"},{"location":"cox/#SurvivalModels.CoxV2","page":"Cox models","title":"SurvivalModels.CoxV2","text":"CoxV2(T, Δ, X)\nfit(CoxV2, @formula(Surv(T,Δ)~X), data = ...)\n\nThe second implementation of the Cox proportional hazards model uses a Newton-Raphson-like iterative update that directly calculates and utilizes the gradient and Hessian matrix. This version is updating coefficients via the update! function.\n\nFields:     - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features     - T::Vector{Float64}: The observed times, sorted in ascending order     - Δ::Vector{Int64}: The event indicator vector (true for event, false for censoring)     - R::BitMatrix: A boolean risk matrix, where 'R[i,j]' is 'true' if individual 'j' is at risk at time 'T[i]'\n\n\n\n\n\n","category":"type"},{"location":"cox/#V3:-Improved-version-of-V2-(much-faster)-because-non-allocative.","page":"Cox models","title":"V3: Improved version of V2 (much faster) because non-allocative.","text":"","category":"section"},{"location":"cox/#SurvivalModels.CoxV3","page":"Cox models","title":"SurvivalModels.CoxV3","text":"CoxV3(T, Δ, X)\nfit(CoxV3, @formula(Surv(T,Δ)~X), data = ...)\nfit(Cox, @formula(Surv(T,Δ)~X), data = ...)\n\nThe third implementation of the Cox proportional hazards model represents a highly optimized and significantly faster iteration compared to previous implementation, CoxV2.\n\nThis is the default implementation called when you ask for a Cox model. \n\nFields:     - Xᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)     - sX::Vector{Float64}: Sum of X' multiplied by Δ     - T::Vector{Float64}: The observed times sorted in descending order     - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)     - loss::Vector{Float64}: Stores the current negative partial log-likelihood value     - G::Vector{Float64}: Stores the gradient vector       - H::Matrix{Float64}: Stores the Hessian matrix      - S₁::Vector{Float64}: Sum of rⱼxₖⱼ     - S₂::Matrix{Float64}: Sum of rⱼxₖⱼ * xⱼ     - μ::Vector{Float64}: Updates the gradient and Hessian     - η::Vector{Float64}: ηi = Xiβ     - r::Vector{Float64}: ri = exp(ηi)     - R::Vector{UnitRange{Int64}}: A vector of the risk ranges for each output time.\n\n\n\n\n\n","category":"type"},{"location":"cox/#V4:-Majoration-of-the-Hessian-matrix-by-a-universal-bound.","page":"Cox models","title":"V4: Majoration of the Hessian matrix by a universal bound.","text":"","category":"section"},{"location":"cox/#SurvivalModels.CoxV4","page":"Cox models","title":"SurvivalModels.CoxV4","text":"CoxV4(T, Δ, X)\nfit(CoxV4, @formula(Surv(T,Δ)~X), data = ...)\n\nThe fourth implementation of the Cox proportional hazards model uses Hessian approximation based on a pre-calculated estimation. This version was created for when it might be difficult to work with full Hessian , offering faster iterations by using a Hessian approximation.\n\nFields:     - X::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features     - T::Vector{Float64}: The observed times sorted in ascending order     - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)     - sX::Vector{Float64}: Sum of X' multiplied by Δ     - G::Vector{Float64}: Stores the gradient vector     - η::Vector{Float64}: ηi = Xiβ     - A::Vector{Float64}: Ai = exp(ηi)     - B::Vector{Float64}: Stores the majoration elements of the Hessian matrix     - C::Vector{Float64}: Used in the mkA! function     - K::Vector{Int64}: Number of events at each unique observed event time     - loss::Vector{Float64}: Stores the current negative partial log-likelihood value, used in CoxLLH getβ\n\n\n\n\n\n","category":"type"},{"location":"cox/#V5","page":"Cox models","title":"V5","text":"","category":"section"},{"location":"cox/#SurvivalModels.CoxV5","page":"Cox models","title":"SurvivalModels.CoxV5","text":"CoxV5(T, Δ, X)\nfit(CoxV5, @formula(Surv(T,Δ)~X), data = ...)\n\nThe fifth implementation of the Cox proportional hazards model uses a pre-calculated Hessian approximation for faster iterations, like CoxV4. Its approach is similar to CoxV3.\n\nFields:     - Xᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)     - sX::Vector{Float64}: Sum of X' multiplied by Δ     - T::Vector{Float64}: The observed times sorted in descending order     - Δ::Vector{Bool}: The event indicator vector (true for event, false for censoring)     - loss::Vector{Float64}: Stores the current negative partial log-likelihood value     - G::Vector{Float64}: Stores the gradient vector.     - S₁::Vector{Float64}:  Sum of rⱼxₖⱼ     - μ::Vector{Float64}: Currently unused in update! function     - η::Vector{Float64}: ηi = Xiβ     - r::Vector{Float64}: ri = exp(ηi)     - R::Vector{UnitRange{Int64}}:     - B::Vector{Float64}: Stores the majoration elements of the Hessian matrix\n\n\n\n\n\n","category":"type"},{"location":"cox/#Comparison-of-the-different-methods-speed","page":"Cox models","title":"Comparison of the different methods speed","text":"","category":"section"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"We propose to compare the different methods on simulated data, with varying number of lines and columns, to verify empirically the theoretical complexity of the different methods.  We will then compare the results with Julia's and R's existing Cox implementation.","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"using SurvivalModels, Plots, Random, Distributions, StatsBase, LinearAlgebra, DataFrames, RCall, Survival\n\nusing SurvivalModels: getβ, CoxV0, CoxV1, CoxV2, CoxV3, CoxV4, CoxV5","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"struct CoxVJ\n    T::Vector{Float64}\n    Δ::Vector{Bool}\n    X::Matrix{Float64}\n    function CoxVJ(T,Δ,X)\n        new(T,Bool.(Δ),X)\n    end\nend\n\nfunction SurvivalModels.getβ(M::CoxVJ)\n    return fit(Survival.CoxModel, M.X, Survival.EventTime.(M.T,M.Δ)).β\nend\n","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"R\"\"\"\nlibrary(survival)\n\"\"\"\n\nstruct CoxVR\n    df::DataFrame\n    function CoxVR(T,Δ,X)\n        df = DataFrame(X,:auto)\n        df.status = Δ\n        df.time = T\n        new(df)\n    end\nend\n\nfunction SurvivalModels.getβ(M::CoxVR)\n    df = M.df\n    @rput df\n    R\"\"\"\n    beta  <- coxph(Surv(time,status)~., data = df, ties=\"breslow\")$coefficients\n    \"\"\"\n    @rget beta\n    return beta\nend","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"# Creating a dictionary for all the models:\n# Label => (constructor, plotting color)\n\nconst design = Dict(\n\"V0\"=> (CoxV0, :blue),\n\"V1\"=> (CoxV1, :orange),\n\"V2\"=> (CoxV2, :brown),\n\"V3\"=> (CoxV3, :purple),\n\"V4\"=> (CoxV4, :green),\n\"V5\"=> (CoxV5, :yellow),\n\"VR\"=> (CoxVR, :red),\n\"VJ\"=> (CoxVJ, :black)\n);\n\n# Function to simulate data for different rows and column numbers (n max = 2000 et m max = 20):\nfunction simulate_survival_data(n, m; censor_rate = 0.2, β=randn(m))\n    Random.seed!(42)\n    X = hcat(\n        [randn(n)       for _ in 1:cld(m,3)]..., # about 1/3\n        [rand(n)        for _ in 1:cld(m,3)]..., # about 1/3\n        [exp.(randn(n)) for _ in 1:(m-2cld(m,3))]... # the rest. \n    )\n    η = X * β\n    λ₀ = 1 \n    U = rand(n)\n    O = -log.(U) ./ (λ₀ .* exp.(η))\n    lc = quantile(O, 1 - censor_rate)\n    C = rand(Exponential(lc), n)\n    T = min.(O, C)\n    Δ = Bool.(T .<= C)\n    return (T, Δ, X)\nend\n\n# Run the models and get the running time, the β coefficients and the difference between the true β and the obtained ones: \nfunction run_models() \n    Ns = (500, 1000, 2000) \n    Ms = (10, 20) \n    true_betas = randn(maximum(Ms))\n    df = []\n    for n in Ns, m in Ms\n        if (n == 2000) | (m == 20) # Only if they end up in the graphs.\n            data = simulate_survival_data(n,m, β = true_betas[1:m])\n            for (name, (constructor, _)) in design\n                display((n,m,name))\n                model = constructor(data...)\n                beta = getβ(model)\n                time = @elapsed getβ(model)\n                push!(df, (\n                    n = n, \n                    m = m, \n                    name = name, \n                    time = time,\n                    beta = beta,\n                    diff_to_truth = sqrt(sum((beta .- true_betas[1:m]).^2)/sum(true_betas[1:m].^2)),\n                ))\n            end\n        end\n    end\n    df = DataFrame(df)\n    sort!(df, :name)\n    return df\nend\n\n# Plot the results, starting with the time: \nfunction timing_graph(df)\n    group1 = groupby(filter(r -> r.m==20, df), :name)\n    p1 = plot(; xlabel = \"Number of observations (n)\",\n        ylabel = \"Time (in seconds)\",\n        yscale= :log10,\n        xscale= :log10,\n        title = \"For m=20 covs., varying n\",\n        legend = :bottomright,\n        lw = 1);\n    for g in group1\n        plot!(p1, g.n, g.time, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n    end\n    group2 = groupby(filter(r -> r.n==2000, df), :name)\n        p2 = plot(; xlabel = \"Number of covariates (m)\",\n            ylabel = \"Temps (ms)\",\n            yscale= :log10,\n            xscale= :log10,\n            title = \"For n=2000 obs., varying m\",\n            legend = :bottomright,\n            lw = 1);\n        for g in group2\n            plot!(p2, g.m, g.time, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n        end\n        p = plot(p1,p2, size=(1200,600), plot_title = \"Runtime (logscale) of the various implementations\")\n        return p\nend","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"df = run_models()\ntiming_graph(df)","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"comments on the graph. ","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"A zoom on our implementation vs Survival.jl vs R::survival: ","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"timing_graph(filter(r -> r.name ∈ (\"V3\", \"VJ\", \"VR\"), df))","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"So we are about x10 faster than the reference implmentation of R (and than the previous Julia attemps) on this example. ","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"function beta_correctness_graphs(df; ref=\"VJ\")\n    \n    reflines = filter(r -> r.name == ref, df)\n    rename!(reflines, :beta => :refbeta)\n    select!(reflines, Not([:name, :time, :diff_to_truth]))\n    otherlines = filter(r -> r.name != ref, df)\n    rez = leftjoin(otherlines, reflines, on=[:n,:m])\n    percent(x,y) = sqrt(sum((x .- y).^2)/sum(y .^2))\n    rez.error = percent.(rez.beta, rez.refbeta)\n    select!(rez, [:n,:m,:name,:error])\n    rez = filter!(r -> !isnan(r.error), rez)\n    \n    group1 = groupby(filter(r -> r.m==20, rez), :name)\n    p1 = plot(; xlabel = \"Number of observations (n)\",\n                ylabel = \"L2dist to $ref's β\",\n                yscale=:log10,\n                xscale= :log10,\n                title = \"m=20, varying n\",\n                legend = :bottomright,\n                lw = 1);\n    for g in group1\n        plot!(p1, g.n, g.error, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n    end\n\n    group2 = groupby(filter(r -> r.n==2000, rez), :name)\n    p2 = plot(; xlabel = \"Nomber of covariates (m)\",\n                ylabel = \"L2Dist to $ref's β\",\n                yscale=:log10,\n                xscale= :log10,\n                title = \"n=2000, varying m\",\n                legend = :bottomright,\n                lw = 1);\n    for g in group2\n        plot!(p2, g.m, g.error, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n    end\n    p = plot(p1,p2, size=(1200,600), plot_title=\"β-correctness w.r.t. $ref's version.\")\n    return p\nend\n\nbeta_correctness_graphs(df)","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"function beta_wrt_truth(df)\n    group1 = groupby(filter(r -> r.m==20, df), :name)\n    p1 = plot(; xlabel = \"Number of observations (n)\",\n                ylabel = \"L2dist to the truth\",\n                yscale=:log10,\n                xscale= :log10,\n                title = \"m=20, varying n\",\n                legend = :bottomright,\n                lw = 1);\n    for g in group1\n        plot!(p1, g.n, g.diff_to_truth, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n    end\n\n    group2 = groupby(filter(r -> r.n==2000, df), :name)\n    p2 = plot(; xlabel = \"Nomber of covariates (m)\",\n                ylabel = \"L2Dist to the truth\",\n                yscale=:log10,\n                xscale= :log10,\n                title = \"n=2000, varying m\",\n                legend = :bottomright,\n                lw = 1);\n    for g in group2\n        plot!(p2, g.m, g.diff_to_truth, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n    end\n    p = plot(p1,p2, size=(1200,600), plot_title=\"β-correctness w.r.t. the truth.\")\n    return p\nend   \n\nbeta_wrt_truth(df)","category":"page"},{"location":"cox/","page":"Cox models","title":"Cox models","text":"D. R. Cox. Regression models and life-tables. Journal of the Royal Statistical Society: Series B (Methodological) 34, 187–202 (1972).\n\n\n\n","category":"page"},{"location":"#SurvivalModels","page":"Home","title":"SurvivalModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SurvivalModels.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this documentation, we can cite stuff from the references.bib file like that : [1]. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation shall cover all the content of the package, which is not the case yet. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"D. R. Cox. Regression models and life-tables. Journal of the Royal Statistical Society: Series B (Methodological) 34, 187–202 (1972).\n\n\n\n","category":"page"}]
}
