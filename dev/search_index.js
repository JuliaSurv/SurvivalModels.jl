var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/#SurvivalModels.AcceleratedFaillureTime-references","page":"References","title":"SurvivalModels.AcceleratedFaillureTime","text":"AcceleratedFaillureTime(T, Δ, baseline, X1, X2)\nfit(AcceleratedFaillureTime, @formula(Surv(T, Δ) ~ x1 + x2), df)\n\nFit an Accelerated Failure Time (AFT) model with a specified baseline distribution and covariates.\n\nHazard function\n\nh(t  x) = h_0left(t exp(x^top beta)right) exp(x^top beta)\n\nT: Vector of observed times.\nΔ: Vector of event indicators (1=event, 0=censored).\nbaseline: Baseline distribution (e.g., Weibull()).\nX1, X2: Covariate matrices (only X1 is used in AFT).\n\nYou can also use the fit() interface with a formula and DataFrame.\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.AcceleratedHazard-references","page":"References","title":"SurvivalModels.AcceleratedHazard","text":"AcceleratedHazard(T, Δ, baseline, X1, X2)\nfit(AcceleratedHazard, @formula(Surv(T, Δ) ~ x1 + x2), df)\n\nFit an Accelerated Hazard (AH) model with a specified baseline distribution and covariates.\n\nHazard function\n\nh(t  z) = h_0left(t exp(z^top alpha)right)\n\nT: Vector of observed times.\nΔ: Vector of event indicators (1=event, 0=censored).\nbaseline: Baseline distribution (e.g., Weibull()).\nX1, X2: Covariate matrices (only X2 is used in AH).\n\nYou can also use the fit() interface with a formula and DataFrame.\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.Cox-references","page":"References","title":"SurvivalModels.Cox","text":"StatsBase.fit(Cox, @formula(Surv(T,Δ)~predictors), dataset)\n\nArguments: \n\nT: The Cox model type to fit (CoxV3)\nformula: A StatsModels.FormulaTerm specifying the survival model\ndf: A DataFrame containing the variables specified in the formula\n\nReturns: \n\npredictor: A Vector{String} containing the names of the predictor variables included in the model\nbeta: A Vector{Float64} containing the estimated regression coefficients (β​) for each predictor\nse: A Vector{Float64} containing the standard errors of the estimated regression coefficients\nloglikelihood: A Vector{Float64} containing the log-likelihood of the fitted model. This value is repeated for each predictor row \ncoef: A vector of the estimated coefficients\nformula: The applied formula\n\nExample:\n\novarian = dataset(\"survival\", \"ovarian\")\novarian.FUTime = Float64.(ovarian.FUTime) (Time column needs to be Float64 type)\novarian.FUStat = Bool.(ovarian.FUStat) (Status column needs to be Bool type)\nmodel = fit(Cox, @formula(Surv(FUTime, FUStat) ~ Age + ECOG_PS), ovarian)\n\nTypes: \n\nCox : the base abstract type\nCoxGrad<:Cox : abstract type for Cox models that are solved using gradient-based optimization\nCoxLLH<:CoxGrad : abstract type for Cox models that are solved by optimizing the log-likelihood\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV0-references","page":"References","title":"SurvivalModels.CoxV0","text":"CoxVO(T, Δ, X)\nfit(CoxV0, @formula(Surv(T,Δ)~X), data = ...)\n\nAn implementation of the Cox proportional hazards model that minimizes the negative partial log-likelihood function (cox_nllh). This version uses the Nelder-Mead method, a derivative-free optimization algorithm. \n\nFields: \n\nX::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features\nT::Vector{Float64}: The observed times, sorted in ascending order \nΔ::Vector{Bool}: The event indicator vector (true for event, false for censoring)\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV1-references","page":"References","title":"SurvivalModels.CoxV1","text":"CoxV1(T, Δ, X)\nfit(CoxV1, @formula(Surv(T,Δ)~X), data = ...)\n\nThe first implementation of the Cox proportional hazards model uses optimization libraries (Optimization.jl, Optim.jl) for coefficient estimation. It uses the BFGS algorithm to minimize the negative partial log-likelihood. \n\nFields: \n\nX::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features.\nT::Vector{Float64}: The observed times, sorted in ascending order\nΔ::Vector{Int64}: The event indicator vector (true for event, false for censoring)\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV2-references","page":"References","title":"SurvivalModels.CoxV2","text":"CoxV2(T, Δ, X)\nfit(CoxV2, @formula(Surv(T,Δ)~X), data = ...)\n\nThe second implementation of the Cox proportional hazards model uses a Newton-Raphson-like iterative update that directly calculates and utilizes the gradient and Hessian matrix. This version is updating coefficients via the update! function.\n\nFields:\n\nX::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features\nT::Vector{Float64}: The observed times, sorted in ascending order\nΔ::Vector{Int64}: The event indicator vector (true for event, false for censoring)\nR::BitMatrix: A boolean risk matrix, where 'R[i,j]' is 'true' if individual 'j' is at risk at time 'T[i]'\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV3-references","page":"References","title":"SurvivalModels.CoxV3","text":"CoxV3(T, Δ, X)\nfit(CoxV3, @formula(Surv(T,Δ)~X), data = ...)\nfit(Cox, @formula(Surv(T,Δ)~X), data = ...)\n\nThe third implementation of the Cox proportional hazards model represents a highly optimized and significantly faster iteration compared to previous implementation, CoxV2.\n\nThis is the default implementation called when you ask for a Cox model. \n\nFields:\n\nXᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)\nsX::Vector{Float64}: Sum of X' multiplied by Δ\nT::Vector{Float64}: The observed times sorted in descending order\nΔ::Vector{Bool}: The event indicator vector (true for event, false for censoring)\nloss::Vector{Float64}: Stores the current negative partial log-likelihood value\nG::Vector{Float64}: Stores the gradient vector  \nH::Matrix{Float64}: Stores the Hessian matrix \nS₁::Vector{Float64}: Sum of rⱼxₖⱼ\nS₂::Matrix{Float64}: Sum of rⱼxₖⱼ * xⱼ\nμ::Vector{Float64}: Updates the gradient and Hessian\nη::Vector{Float64}: ηi = Xiβ\nr::Vector{Float64}: ri = exp(ηi)\nR::Vector{UnitRange{Int64}}: A vector of the risk ranges for each output time.\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV4-references","page":"References","title":"SurvivalModels.CoxV4","text":"CoxV4(T, Δ, X)\nfit(CoxV4, @formula(Surv(T,Δ)~X), data = ...)\n\nThe fourth implementation of the Cox proportional hazards model uses Hessian approximation based on a pre-calculated estimation. This version was created for when it might be difficult to work with full Hessian , offering faster iterations by using a Hessian approximation.\n\nFields:\n\nX::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features\nT::Vector{Float64}: The observed times sorted in ascending order\nΔ::Vector{Bool}: The event indicator vector (true for event, false for censoring)\nsX::Vector{Float64}: Sum of X' multiplied by Δ\nG::Vector{Float64}: Stores the gradient vector\nη::Vector{Float64}: ηi = Xiβ\nA::Vector{Float64}: Ai = exp(ηi)\nB::Vector{Float64}: Stores the majoration elements of the Hessian matrix\nC::Vector{Float64}: Used in the mkA! function\nK::Vector{Int64}: Number of events at each unique observed event time\nloss::Vector{Float64}: Stores the current negative partial log-likelihood value, used in CoxLLH getβ\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.CoxV5-references","page":"References","title":"SurvivalModels.CoxV5","text":"CoxV5(T, Δ, X)\nfit(CoxV5, @formula(Surv(T,Δ)~X), data = ...)\n\nThe fifth implementation of the Cox proportional hazards model uses a pre-calculated Hessian approximation for faster iterations, like CoxV4. Its approach is similar to CoxV3.\n\nFields:\n\nXᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)\nsX::Vector{Float64}: Sum of X' multiplied by Δ\nT::Vector{Float64}: The observed times sorted in descending order\nΔ::Vector{Bool}: The event indicator vector (true for event, false for censoring)\nloss::Vector{Float64}: Stores the current negative partial log-likelihood value\nG::Vector{Float64}: Stores the gradient vector.\nS₁::Vector{Float64}:  Sum of rⱼxₖⱼ\nμ::Vector{Float64}: Currently unused in update! function\nη::Vector{Float64}: ηi = Xiβ\nr::Vector{Float64}: ri = exp(ηi)\nR::Vector{UnitRange{Int64}}:\nB::Vector{Float64}: Stores the majoration elements of the Hessian matrix\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.GeneralHazard-references","page":"References","title":"SurvivalModels.GeneralHazard","text":"GeneralHazard(T, Δ, baseline, X1, X2)\nfit(GeneralHazard, @formula(Surv(T, Δ) ~ x1 + x2), @formula(Surv(T, Δ) ~ z1 + z2), df)\nfit(GeneralHazard, @formula(Surv(T, Δ) ~ x1 + x2), df)\n\nFit a General Hazard (GH) model with a specified baseline distribution and covariates.\n\nHazard function\n\nh(t  x z) = h_0left(t exp(z^top alpha)right) exp(x^top beta)\n\nMaximum likelihood estimation in General Hazards models using provided baseline distribution, provided hazard structure (through the method argument), provided design matrices.. \n\nParameters T,Δ represent observed times and statuses, while X1, X2 should contain covariates. The number of columns in design matrices can be zero. \n\nHazard structures are defined by the method, which should be <:AbstractGHMethod, available possibilities are PHMethod(), AFTMethod(), AHMethod() and GHMethod().\n\nThe baseline distribution should be provided as a <:Distributions.ContinuousUnivariateDistribution object from Distributions.jl or compliant, e.g. from SurvivalDistributions.jl.\n\nT: Vector of observed times.\nΔ: Vector of event indicators (1=event, 0=censored).\nbaseline: Baseline distribution (e.g., Weibull()).\nX1, X2: Covariate matrices.\n\nYou can also use the fit() interface with:\n\nTwo formulas (for X1 and X2): for full GH models.\nOne formula: for PH, AFT, or AH models (the unused matrix will be ignored).\n\nExample: Direct usage\n\nusing SurvivalModels, Distributions, Optim\nT = [2.0, 3.0, 4.0, 5.0, 8.0]\nΔ = [1, 1, 0, 1, 0]\nX1 = [1.0 2.0; 2.0 1.0; 3.0 1.0; 4.0 2.0; 5.0 1.0]\nX2 = [1.0 0.0; 0.0 1.0; 1.0 1.0; 0.0 0.0; 1.0 1.0]\nmodel = GeneralHazard(T, Δ, Weibull, X1, X2)\n\nExample: Using the fit() interface\n\nusing SurvivalModels, DataFrames, Distributions, Optim, StatsModels\ndf = DataFrame(time=T, status=Δ, x1=X1[:,1], x2=X1[:,2], z1=X2[:,1], z2=X2[:,2])\nmodel = fit(GeneralHazard, @formula(Surv(time, status) ~ x1 + x2), @formula(Surv(time, status) ~ z1 + z2), df)\n# Or for PH/AFT/AH models:\nmodel_ph = fit(ProportionalHazard, @formula(Surv(time, status) ~ x1 + x2), df)\n\nReferences: \n\nLink to my reference so that people understand what it is\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.GeneralHazardModel-references","page":"References","title":"SurvivalModels.GeneralHazardModel","text":"GeneralHazardModel{Method, B}\n\nA flexible parametric survival model supporting Proportional Hazards (PH), Accelerated Failure Time (AFT), Accelerated Hazards (AH), and General Hazards (GH) structures.\n\nFields\n\nT: Vector of observed times.\nΔ: Vector of event indicators (true if event, false if censored).\nbaseline: Baseline distribution (e.g., Weibull()).\nX1: Covariate matrix for the first linear predictor (e.g., PH/AFT).\nX2: Covariate matrix for the second linear predictor (e.g., AH/GH).\nα: Coefficient vector for X2.\nβ: Coefficient vector for X1.\n\nConstruction\n\nYou can construct a model directly by providing all parameters:\n\nmodel = GeneralHazardModel(\n    GHMethod(),\n    T, Δ, Weibull(1.0, 2.0),\n    X1, X2,\n    α, β\n)\n\nor fit it from data using the fit interface.\n\nSupported methods: \n\nProportionalHazard: For PH models.\nAcceleratedFaillureTime: For AFT models.\nAcceleratedHazard: For AH models.\nGeneralHazard: For full GH models.\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.KaplanMeier-references","page":"References","title":"SurvivalModels.KaplanMeier","text":"KaplanMeier(T, Δ)\nfit(KaplanMeier, @formula(Surv(T, Δ) ~ 1), df)\n\nEfficient Kaplan-Meier estimator.\n\nMathematical Description\n\nSuppose we observe n individuals, with observed times T_1 T_2 ldots T_n and event indicators Delta_1 Delta_2 ldots Delta_n (Delta_i = 1 if the event occurred, 0 if censored).\n\nLet t_1  t_2  cdots  t_k be the ordered unique event times.\n\nd_j: number of events at time t_j\nY_j: number of individuals at risk just before t_j\n\nThe Kaplan-Meier estimator of the survival function S(t) is:\n\nhatS(t) = prod_t_j leq t left(1 - fracd_jY_jright)\n\nThis product runs over all event times t_j less than or equal to t.\n\nThe Greenwood estimator for the variance of hatS(t) is:\n\nwidehatmathrmVarhatS(t) = hatS(t)^2 sum_t_j leq t fracd_jY_j (Y_j - d_j)\n\nArguments\n\nT: Vector of event or censoring times.\nΔ: Event indicator vector (1 if event, 0 if censored).\n\nStores\n\nt: Sorted unique event times.\n∂N: Number of uncensored deaths at each time point.\nY: Number of at risk individuals at each time point.\n∂Λ: Increments of cumulative hazard.\n∂σ: Greenwood variance increments.\n\nExample: Direct usage\n\nusing SurvivalModels\nT = [2, 3, 4, 5, 8]\nΔ = [1, 1, 0, 1, 0]\nkm = KaplanMeier(T, Δ)\n\nExample: Using the fit() interface\n\nusing SurvivalModels, DataFrames, StatsModels\ndf = DataFrame(time=T, status=Δ)\nkm2 = fit(KaplanMeier, @formula(Surv(time, status) ~ 1), df)\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.LogRankTest-references","page":"References","title":"SurvivalModels.LogRankTest","text":"LogRankTest(T, Δ, group, strata)\nfit(LogRankTest, @formula(Surv(T, Δ) ~ gr), data = ...)\nfit(LogRankTest, @formula(Surv(T, Δ) ~ Strata(st) + gr), data = ...)\n\nPerforms the stratified log-rank test for comparing survival distributions across groups.\n\nArguments\n\nT: Vector of observed times.\nΔ: Vector of event indicators (1 = event, 0 = censored).\ngroup: Vector indicating group membership (e.g., treatment arm).\nstrata: Vector indicating strata membership (e.g., baseline strata).\ngr and st are the variables in the DataFrame defining the groups and strata for the fit interface.\n\nReturns\n\nA LogRankTest object with the following fields:\n\nstat: Chi-square test statistic.\ndf: Degrees of freedom (number of groups minus 1).\npval: P-value of the test.\n\nNotes\n\nImplements the stratified log-rank test by aggregating test statistics and variances over strata.\nSuitable for right-censored survival data with stratification.\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.ProportionalHazard-references","page":"References","title":"SurvivalModels.ProportionalHazard","text":"ProportionalHazard(T, Δ, baseline, X1, X2)\nfit(ProportionalHazard, @formula(Surv(T, Δ) ~ x1 + x2), df)\n\nFit a Proportional Hazards (PH) model with a specified baseline distribution and covariates.\n\nHazard function\n\nh(t  x) = h_0(t) exp(x^top beta)\n\nT: Vector of observed times.\nΔ: Vector of event indicators (1=event, 0=censored).\nbaseline: Baseline distribution (e.g., Weibull()).\nX1, X2: Covariate matrices (only X1 is used in PH).\n\nYou can also use the fit() interface with a formula and DataFrame.\n\n\n\n\n\n","category":"type"},{"location":"references/#SurvivalModels.greenwood-Tuple{KaplanMeier, Any}-references","page":"References","title":"SurvivalModels.greenwood","text":"greenwood(S::KaplanMeier, t)\n\nCompute the Greenwood variance estimate for the Kaplan-Meier survival estimator at time t.\n\nThe Greenwood formula provides an estimate of the variance of the Kaplan-Meier survival function at a given time point. For a fitted Kaplan-Meier object S, the variance at time t is:\n\n```math \\widehat{\\mathrm{Var}}[\\hat{S}(t)] = \\hat{S}(t)^2 \\sum{tj < t} \\frac{dj}{Yj (Yj - dj)}\n\n\n\n\n\n","category":"method"},{"location":"references/#SurvivalModels.simGH-Union{Tuple{B}, Tuple{M}, Tuple{Any, SurvivalModels.GeneralHazardModel{M, B}}} where {M, B}-references","page":"References","title":"SurvivalModels.simGH","text":"simGH(n, model::GeneralHazardModel)\n\nThis function simulate times to event from a general hazard model, whatever the structure it has (AH, AFT, PH, GH), and whatever its baseline distribution. \n\nReturns a vector containing the simulated times to event\n\nReferences: \n\nHazReg original code \n\n\n\n\n\n","category":"method"},{"location":"references/","page":"References","title":"References","text":"E. L. Kaplan and P. Meier. Nonparametric estimation from incomplete observations. Journal of the American statistical association 53, 457–481 (1958).\n\n\n\nM. Greenwood. The natural duration of cancer. Reports on Public Health and Medical Subjects 33, 1–26 (1926).\n\n\n\nN. Mantel. Evaluation of survival data and two new rank order statistics arising in its consideration. Cancer chemotherapy reports 50, 163–170 (1966).\n\n\n\nD. R. Cox. Regression models and life-tables. Journal of the Royal Statistical Society: Series B (Methodological) 34, 187–202 (1972).\n\n\n\nY. Chen and N. Jewell. On a general class of semiparametric hazards regression models. Biometrika 88, 687–702 (2001).\n\n\n\nF. Rubio, L. Remontet, N. Jewell and A. Belot. On a general structure for hazard-based regression models: an application to population-based cancer research. Statistical Methods in Medical Research 28, 2404–2417 (2019).\n\n\n\nJ. Kalbfleisch and R. Prentice. The statistical analysis of failure time data (John Wiley & Sons, 2011).\n\n\n\nD. Cox. Regression models and life-tables. Journal of the Royal Statistical Society: Series B (Methodological) 34, 187–202 (1972).\n\n\n\nY. Chen and M. Wang. Analysis of accelerated hazards models. Journal of the American Statistical Association 95, 608–618 (2000).\n\n\n\n","category":"page"},{"location":"references/","page":"References","title":"References","text":"A. Eletti, G. Marra, M. Quaresma, R. Radice and F. Rubio. A unifying framework for flexible excess hazard modelling with applications in cancer epidemiology. Journal of the Royal Statistical Society: Series C NA, in press (2022).\n\n\n\nF. Rubio, B. Rachet, B. Giorgi, C. Maringe and A. Belot. On models for the estimation of the excess mortality hazard in case of insufficiently stratified life tables. Biostatistics, na–na (2019).\n\n\n\nM. Nikulin and F. Haghighi. On the power generalized Weibull family: model for cancer censored data. Metron – International Journal of Statistics 67, 75–86 (2009).\n\n\n\nE. Stacy. A generalization of the gamma distribution. The Annals of Mathematical Statistics 33, 1187–1192 (1962).\n\n\n\n","category":"page"},{"location":"case_study/#Case-Study:-Survival-Analysis-on-the-Colon-Dataset","page":"Case Study","title":"Case Study: Survival Analysis on the Colon Dataset","text":"","category":"section"},{"location":"case_study/#Dataset-Description","page":"Case Study","title":"Dataset Description","text":"","category":"section"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"The colon dataset from the R survival package contains data from a clinical trial of colon cancer patients.   Key variables include:","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Time: Survival or censoring time (days)\nStatus: Event indicator (1 = death, 0 = censored)\nRx: Treatment group (Obs, Lev, Lev+5FU)\nSex: Sex (1 = male, 0 = female)\nAge: Age at entry\nNode: Number of positive lymph nodes\nExtent: Extent of local spread (1 = confined, 2 = adjacent, 3 = adherent, 4 = invaded)\nDiffer: Tumor differentiation (1 = well, 2 = moderate, 3 = poor)\nPerfor: Perforation (0 = no, 1 = yes)","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Let’s load and inspect the data:","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"using SurvivalModels, RDatasets, DataFrames, Plots\ncolon = dataset(\"survival\", \"colon\")\ncolon.Time = Float64.(colon.Time)\ncolon.Status = Bool.(colon.Status)\nfirst(colon, 5)\ndescribe(colon)","category":"page"},{"location":"case_study/#Exploratory-Analysis","page":"Case Study","title":"Exploratory Analysis","text":"","category":"section"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Let’s look at the distribution of survival times and events:","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"histogram(colon.Time, bins=50, xlabel=\"Time (days)\", ylabel=\"Frequency\", title=\"Distribution of Survival Times\")\nsum(colon.Status), length(colon.Status) - sum(colon.Status) # events, censored","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Let’s check the treatment groups and other covariates:","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"unique(colon.Rx)\ncombine(groupby(colon, :Rx), nrow)","category":"page"},{"location":"case_study/#Kaplan-Meier-Estimator","page":"Case Study","title":"Kaplan-Meier Estimator","text":"","category":"section"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Estimate and plot the overall survival curve:","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"km = fit(KaplanMeier, @formula(Surv(Time, Status) ~ 1), colon)\nplot(km.t, cumprod(1 .- km.∂Λ), title = \"Kaplan-Meier estimator\", xlabel=\"Time (days)\", ylabel=\"Survival probability\")","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Compare survival curves by treatment group:","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"km_obs = fit(KaplanMeier, @formula(Surv(Time, Status) ~ 1), colon[colon.Rx .== \"Obs\", :])\nkm_lev = fit(KaplanMeier, @formula(Surv(Time, Status) ~ 1), colon[colon.Rx .== \"Lev\", :])\nkm_lev5fu = fit(KaplanMeier, @formula(Surv(Time, Status) ~ 1), colon[colon.Rx .== \"Lev+5FU\", :])\nplot(km_obs.t, cumprod(1 .- km_obs.∂Λ), label=\"Obs\", xlabel=\"Time (days)\", ylabel=\"Survival probability\")\nplot!(km_lev.t, cumprod(1 .- km_lev.∂Λ), label=\"Lev\")\nplot!(km_lev5fu.t, cumprod(1 .- km_lev5fu.∂Λ), label=\"Lev+5FU\", title=\"KM by Treatment Group\")","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Regrouping the two similar curves, we get (including confidence intervals): ","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Let’s regroup \"Lev\" and \"Lev+5FU\" as a single treatment group, and compare it to \"Obs\".","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"# Create a new treatment variable\ncolon.TreatGroup = ifelse.(colon.Rx .== \"Obs\", \"Obs\", \"Lev+5FU or Lev\")\n\n# Fit KM for each group\nkm_obs = fit(KaplanMeier, @formula(Surv(Time, Status) ~ 1), colon[colon.TreatGroup .== \"Obs\", :])\nkm_levgroup = fit(KaplanMeier, @formula(Surv(Time, Status) ~ 1), colon[colon.TreatGroup .== \"Lev+5FU or Lev\", :])\n\n# Get survival and confidence intervals from the package\nci_obs = confint(km_obs)\nci_lev = confint(km_levgroup)\n\n# Plot\nplot(ci_obs.time, ci_obs.surv, ribbon=(ci_obs.surv .- ci_obs.lower, ci_obs.upper .- ci_obs.surv),\n     label=\"Obs\", color=:blue, xlabel=\"Time (days)\", ylabel=\"Survival probability\",\n     title=\"KM by Regrouped Treatment\", legend=:bottomleft)\nplot!(ci_lev.time, ci_lev.surv, ribbon=(ci_lev.surv .- ci_lev.lower, ci_lev.upper .- ci_lev.surv),\n      label=\"Lev+5FU or Lev\", color=:red)","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"This plot shows the Kaplan-Meier survival curves for the two treatment groups, with 95% confidence intervals.","category":"page"},{"location":"case_study/#Log-Rank-Test","page":"Case Study","title":"Log-Rank Test","text":"","category":"section"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Test for differences in survival between treatment groups:","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"lrt = fit(LogRankTest, @formula(Surv(Time, Status) ~ TreatGroup), colon)\nlrt.stat, lrt.pval","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Interpretation: A small p-value suggests significant differences in survival between groups.","category":"page"},{"location":"case_study/#Cox-Proportional-Hazards-Model","page":"Case Study","title":"Cox Proportional Hazards Model","text":"","category":"section"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Fit a Cox model with treatment and other covariates:","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"fit(Cox, @formula(Surv(Time, Status) ~ TreatGroup + Sex + Age), colon)","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Interpretation: The coefficients show the log hazard ratios for each covariate.","category":"page"},{"location":"case_study/#General-Hazard-Models-(GHMs)","page":"Case Study","title":"General Hazard Models (GHMs)","text":"","category":"section"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"TODO","category":"page"},{"location":"case_study/#Model-Comparison","page":"Case Study","title":"Model Comparison","text":"","category":"section"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"Let’s compare the quality of the fits using log-likelihood and AIC:","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"TODO","category":"page"},{"location":"case_study/#Performance-(Optional)","page":"Case Study","title":"Performance (Optional)","text":"","category":"section"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"You can also compare computation times:","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"TODO","category":"page"},{"location":"case_study/#Summary","page":"Case Study","title":"Summary","text":"","category":"section"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"The colon dataset provides a rich set of covariates for survival analysis.\nKaplan-Meier curves show overall and group-wise survival.\nLog-rank tests confirm differences between treatment groups.\nCox and General Hazard Models allow for multivariate modeling and flexible hazard shapes.","category":"page"},{"location":"case_study/","page":"Case Study","title":"Case Study","text":"This case study can be extended with further diagnostics, stratified analyses, and more advanced parametric models as needed.","category":"page"},{"location":"parametric/generalhazard/#General-Hazard-Models","page":"General Hazard","title":"General Hazard Models","text":"","category":"section"},{"location":"parametric/generalhazard/#Hazard-and-cumulative-hazard-functions","page":"General Hazard","title":"Hazard and cumulative hazard functions","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"The hazard and the cumulative hazard functions play a crucial role in survival analysis. These functions define the likelihood function in the presence of censored observations. Thus, they are important in many context. For more information about these functions, see Short course on Parametric Survival Analysis .","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"In Julia, hazard and cumulative hazard functions can be fetched through the hazard(dist, t) and cumhaz(dist, t) functions from SurvivalDistributions.jl, and can be aplied to any distributions complient with Distributions.jl's API. Note that SurvivalDistributions.jl also contains a few more distributions relevant to survival analysis. See also the (deprecated) HazReg.jl Julia Package. ","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"Here are a few plots of hazard curves for some known distributions: ","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"using Distributions, Plots, StatsBase, SurvivalDistributions\nfunction hazard_cumhazard_plot(dist, distname; tlims=(0,10))\n      plt1 = plot(t -> hazard(dist, t),\n            xlabel = \"x\", ylabel = \"Hazard\", title = \"$distname distribution\",\n            xlims = tlims, xticks = tlims[1]:1:tlims[2], label = \"\",\n            xtickfont = font(16, \"Courier\"), ytickfont = font(16, \"Courier\"),\n            xguidefontsize=18, yguidefontsize=18, linewidth=3,\n            linecolor = \"blue\")\n      plt2 = plot(t -> cumhazard(dist, t),\n            xlabel = \"x\", ylabel = \"Cumulative Hazard\", title = \"$distname distribution\",\n            xlims = tlims, xticks = tlims[1]:1:tlims[2], label = \"\",\n            xtickfont = font(16, \"Courier\"), ytickfont = font(16, \"Courier\"),\n            xguidefontsize=18, yguidefontsize=18, linewidth=3,\n            linecolor = \"blue\")\n      return plot(plt1, plt2)\nend","category":"page"},{"location":"parametric/generalhazard/#LogNormal","page":"General Hazard","title":"LogNormal","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"hazard_cumhazard_plot(LogNormal(0.5, 1), \"LogNormal\")","category":"page"},{"location":"parametric/generalhazard/#LogLogistic","page":"General Hazard","title":"LogLogistic","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"hazard_cumhazard_plot(LogLogistic(1, 0.5), \"LogLogistic\")","category":"page"},{"location":"parametric/generalhazard/#Weibull","page":"General Hazard","title":"Weibull","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"hazard_cumhazard_plot(Weibull(3, 0.5), \"Weibull\")","category":"page"},{"location":"parametric/generalhazard/#Gamma","page":"General Hazard","title":"Gamma","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"hazard_cumhazard_plot(Gamma(3, 0.5), \"Gamma\")","category":"page"},{"location":"parametric/generalhazard/#General-Hazard-Models-2","page":"General Hazard","title":"General Hazard Models","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"The GH model is formulated in terms of the hazard structure","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"h(t alpha beta theta bf x) = h_0left(t  exptildebf x^topalpha thetaright) expbf x^topbeta","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"where bf xinmathbb R^p are the covariates that affect the hazard level; tildebf x in mathbb R^q are the covariates the affect the time level (typically tildebf x subset bf x); alpha in mathbb R^q and beta in mathbb R^p are the regression coefficients; and theta in Theta is the vector of parameters of the baseline hazard h_0(cdot).","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"This hazard structure leads to an identifiable model as long as the baseline hazard is not a hazard associated to a member of the Weibull family of distributions [5]. ","category":"page"},{"location":"parametric/generalhazard/#SurvivalModels.GeneralHazardModel","page":"General Hazard","title":"SurvivalModels.GeneralHazardModel","text":"GeneralHazardModel{Method, B}\n\nA flexible parametric survival model supporting Proportional Hazards (PH), Accelerated Failure Time (AFT), Accelerated Hazards (AH), and General Hazards (GH) structures.\n\nFields\n\nT: Vector of observed times.\nΔ: Vector of event indicators (true if event, false if censored).\nbaseline: Baseline distribution (e.g., Weibull()).\nX1: Covariate matrix for the first linear predictor (e.g., PH/AFT).\nX2: Covariate matrix for the second linear predictor (e.g., AH/GH).\nα: Coefficient vector for X2.\nβ: Coefficient vector for X1.\n\nConstruction\n\nYou can construct a model directly by providing all parameters:\n\nmodel = GeneralHazardModel(\n    GHMethod(),\n    T, Δ, Weibull(1.0, 2.0),\n    X1, X2,\n    α, β\n)\n\nor fit it from data using the fit interface.\n\nSupported methods: \n\nProportionalHazard: For PH models.\nAcceleratedFaillureTime: For AFT models.\nAcceleratedHazard: For AH models.\nGeneralHazard: For full GH models.\n\n\n\n\n\n","category":"type"},{"location":"parametric/generalhazard/#SurvivalModels.GeneralHazard","page":"General Hazard","title":"SurvivalModels.GeneralHazard","text":"GeneralHazard(T, Δ, baseline, X1, X2)\nfit(GeneralHazard, @formula(Surv(T, Δ) ~ x1 + x2), @formula(Surv(T, Δ) ~ z1 + z2), df)\nfit(GeneralHazard, @formula(Surv(T, Δ) ~ x1 + x2), df)\n\nFit a General Hazard (GH) model with a specified baseline distribution and covariates.\n\nHazard function\n\nh(t  x z) = h_0left(t exp(z^top alpha)right) exp(x^top beta)\n\nMaximum likelihood estimation in General Hazards models using provided baseline distribution, provided hazard structure (through the method argument), provided design matrices.. \n\nParameters T,Δ represent observed times and statuses, while X1, X2 should contain covariates. The number of columns in design matrices can be zero. \n\nHazard structures are defined by the method, which should be <:AbstractGHMethod, available possibilities are PHMethod(), AFTMethod(), AHMethod() and GHMethod().\n\nThe baseline distribution should be provided as a <:Distributions.ContinuousUnivariateDistribution object from Distributions.jl or compliant, e.g. from SurvivalDistributions.jl.\n\nT: Vector of observed times.\nΔ: Vector of event indicators (1=event, 0=censored).\nbaseline: Baseline distribution (e.g., Weibull()).\nX1, X2: Covariate matrices.\n\nYou can also use the fit() interface with:\n\nTwo formulas (for X1 and X2): for full GH models.\nOne formula: for PH, AFT, or AH models (the unused matrix will be ignored).\n\nExample: Direct usage\n\nusing SurvivalModels, Distributions, Optim\nT = [2.0, 3.0, 4.0, 5.0, 8.0]\nΔ = [1, 1, 0, 1, 0]\nX1 = [1.0 2.0; 2.0 1.0; 3.0 1.0; 4.0 2.0; 5.0 1.0]\nX2 = [1.0 0.0; 0.0 1.0; 1.0 1.0; 0.0 0.0; 1.0 1.0]\nmodel = GeneralHazard(T, Δ, Weibull, X1, X2)\n\nExample: Using the fit() interface\n\nusing SurvivalModels, DataFrames, Distributions, Optim, StatsModels\ndf = DataFrame(time=T, status=Δ, x1=X1[:,1], x2=X1[:,2], z1=X2[:,1], z2=X2[:,2])\nmodel = fit(GeneralHazard, @formula(Surv(time, status) ~ x1 + x2), @formula(Surv(time, status) ~ z1 + z2), df)\n# Or for PH/AFT/AH models:\nmodel_ph = fit(ProportionalHazard, @formula(Surv(time, status) ~ x1 + x2), df)\n\nReferences: \n\nLink to my reference so that people understand what it is\n\n\n\n\n\n","category":"type"},{"location":"parametric/generalhazard/#Accelerated-Failure-Time-(AFT)-model","page":"General Hazard","title":"Accelerated Failure Time (AFT) model","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"The AFT model is formulated in terms of the hazard structure","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"h(t beta theta bf x) = h_0left(t  expbf x^topbeta thetaright) expbf x^topbeta","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"where bf xinmathbb R^p are the available covariates; beta in mathbb R^p are the regression coefficients; and theta in Theta is the vector of parameters of the baseline hazard h_0(cdot).","category":"page"},{"location":"parametric/generalhazard/#SurvivalModels.AcceleratedFaillureTime","page":"General Hazard","title":"SurvivalModels.AcceleratedFaillureTime","text":"AcceleratedFaillureTime(T, Δ, baseline, X1, X2)\nfit(AcceleratedFaillureTime, @formula(Surv(T, Δ) ~ x1 + x2), df)\n\nFit an Accelerated Failure Time (AFT) model with a specified baseline distribution and covariates.\n\nHazard function\n\nh(t  x) = h_0left(t exp(x^top beta)right) exp(x^top beta)\n\nT: Vector of observed times.\nΔ: Vector of event indicators (1=event, 0=censored).\nbaseline: Baseline distribution (e.g., Weibull()).\nX1, X2: Covariate matrices (only X1 is used in AFT).\n\nYou can also use the fit() interface with a formula and DataFrame.\n\n\n\n\n\n","category":"type"},{"location":"parametric/generalhazard/#Proportional-Hazards-(PH)-model","page":"General Hazard","title":"Proportional Hazards (PH) model","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"The PH model is formulated in terms of the hazard structure","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"h(t beta theta bf x) = h_0left(t  thetaright) expbf x^topbeta","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"where bf xinmathbb R^p are the available covariates; beta in mathbb R^p are the regression coefficients; and theta in Theta is the vector of parameters of the baseline hazard h_0(cdot).","category":"page"},{"location":"parametric/generalhazard/#SurvivalModels.ProportionalHazard","page":"General Hazard","title":"SurvivalModels.ProportionalHazard","text":"ProportionalHazard(T, Δ, baseline, X1, X2)\nfit(ProportionalHazard, @formula(Surv(T, Δ) ~ x1 + x2), df)\n\nFit a Proportional Hazards (PH) model with a specified baseline distribution and covariates.\n\nHazard function\n\nh(t  x) = h_0(t) exp(x^top beta)\n\nT: Vector of observed times.\nΔ: Vector of event indicators (1=event, 0=censored).\nbaseline: Baseline distribution (e.g., Weibull()).\nX1, X2: Covariate matrices (only X1 is used in PH).\n\nYou can also use the fit() interface with a formula and DataFrame.\n\n\n\n\n\n","category":"type"},{"location":"parametric/generalhazard/#Accelerated-Hazards-(AH)-model","page":"General Hazard","title":"Accelerated Hazards (AH) model","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"The AH model is formulated in terms of the hazard structure","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"h(t alpha theta tildebf x) = h_0left(t exptildebf x^topalpha thetaright) ","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"where tildebf xinmathbb R^q are the available covariates; alpha in mathbb R^q are the regression coefficients; and theta in Theta is the vector of parameters of the baseline hazard h_0(cdot).","category":"page"},{"location":"parametric/generalhazard/#SurvivalModels.AcceleratedHazard","page":"General Hazard","title":"SurvivalModels.AcceleratedHazard","text":"AcceleratedHazard(T, Δ, baseline, X1, X2)\nfit(AcceleratedHazard, @formula(Surv(T, Δ) ~ x1 + x2), df)\n\nFit an Accelerated Hazard (AH) model with a specified baseline distribution and covariates.\n\nHazard function\n\nh(t  z) = h_0left(t exp(z^top alpha)right)\n\nT: Vector of observed times.\nΔ: Vector of event indicators (1=event, 0=censored).\nbaseline: Baseline distribution (e.g., Weibull()).\nX1, X2: Covariate matrices (only X2 is used in AH).\n\nYou can also use the fit() interface with a formula and DataFrame.\n\n\n\n\n\n","category":"type"},{"location":"parametric/generalhazard/#Available-baseline-hazards","page":"General Hazard","title":"Available baseline hazards","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"The current version of the simGH command implements the following parametric baseline hazards for the models discussed in the previous section.","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"Power Generalised Weibull (PGW) distribution.\nExponentiated Weibull (EW) distribution.\nGeneralised Gamma (GenGamma) distribuiton.\nGamma (Gamma) distribution.\nLognormal (LogNormal) distribution.\nLog-logistic (LogLogistic) distribution.\nWeibull (Weibull) distribution. (only for AFT, PH, and AH models)","category":"page"},{"location":"parametric/generalhazard/#Simulating-times-to-event-from-a-general-hazard-structure-with-simGH","page":"General Hazard","title":"Simulating times to event from a general hazard structure with simGH","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"The simGH command from the HazReg.jl Julia package allows one to simulate times to event from the following models:","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"General Hazard (GH) model [5] [6].\nAccelerated Failure Time (AFT) model [7].\nProportional Hazards (PH) model [8].\nAccelerated Hazards (AH) model [9].","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"A description of these hazard models is presented below as well as the available baseline hazards.","category":"page"},{"location":"parametric/generalhazard/#SurvivalModels.simGH","page":"General Hazard","title":"SurvivalModels.simGH","text":"simGH(n, model::GeneralHazardModel)\n\nThis function simulate times to event from a general hazard model, whatever the structure it has (AH, AFT, PH, GH), and whatever its baseline distribution. \n\nReturns a vector containing the simulated times to event\n\nReferences: \n\nHazReg original code \n\n\n\n\n\n","category":"function"},{"location":"parametric/generalhazard/#Illustrative-example","page":"General Hazard","title":"Illustrative example","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"In this example, we simulate n=1000 times to event from the GH, PH, AFT, and AH models with PGW baseline hazards, using the simGH() function. This functionality was ported from HazReg.jl ","category":"page"},{"location":"parametric/generalhazard/#PGW-GH-model","page":"General Hazard","title":"PGW-GH model","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"using SurvivalModels, Distributions, DataFrames, Random, SurvivalDistributions\nusing SurvivalModels: simGH\n\n# Simulte design matrices\nn = 1000\nRandom.seed!(123)\ndes = randn(n, 2)\ndes_t = randn(n, 2)\n\n# True parameters\ntheta0 = [0.1, 2.0, 5.0]\nalpha0 = [0.5, 0.8]\nbeta0 = [-0.5, 0.75]\n\n# Construct the model directly (no optimization)\nmodel = GeneralHazard(zeros(n), trues(n), \n    PowerGeneralizedWeibull(theta0...),\n    des, des_t, alpha0, beta0)\n\n# Simulate event times\nsimdat = simGH(n, model)\n\n# Administrative censoring. \ncens = 10\nstatus = simdat .< cens\nsimdat = min.(simdat, cens)\n\n# Model fit from dataframe interface. \ndf = DataFrame(time=simdat, status=status, x1=des[:,1], x2=des[:,2], z1=des_t[:,1], z2=des_t[:,2])\nmodel = fit(GeneralHazard{PowerGeneralizedWeibull}, \n    @formula(Surv(time, status) ~ x1 + x2), \n    @formula(Surv(time, status) ~ z1 + z2), \n    df)\n\nresult = DataFrame(\n    Parameter = [\"θ₁\", \"θ₂\", \"θ₃\", \"α₁\", \"α₂\",\"β₁\", \"β₂\"],\n    True      = vcat(theta0, alpha0, beta0),\n    Fitted    = vcat(params(model.baseline)..., model.α, model.β)\n)","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"Of course, increasing hte numebr of observations would increase the quality of the fitted values. You can also use \"subset\" models (PH, AH, AFT) through the convenient constructors as follows: ","category":"page"},{"location":"parametric/generalhazard/#PGW-PH-model","page":"General Hazard","title":"PGW-PH model","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"model = ProportionalHazard(zeros(n), trues(n), \n    PowerGeneralizedWeibull(theta0...),\n    des, zeros(n,0),  # X2 is empty for PH\n    zeros(0), beta0\n)\n\n# Simulate event times and censor them\nsimdat = simGH(n, model)\ncens = 10\nstatus = simdat .< cens\nsimdat = min.(simdat, cens)\n\n\n# Build the model and fit it: \ndf = DataFrame(time=simdat, status=status, x1=des[:,1], x2=des[:,2])\nmodel = fit(ProportionalHazard{PowerGeneralizedWeibull}, \n    @formula(Surv(time, status) ~ x1 + x2), df)\n\nresult = DataFrame(\n    Parameter = [\"θ₁\", \"θ₂\", \"θ₃\", \"β₁\", \"β₂\"],\n    True      = vcat(theta0, beta0),\n    Fitted    = vcat(params(model.baseline)..., model.β)\n)","category":"page"},{"location":"parametric/generalhazard/#PGW-AFT-model","page":"General Hazard","title":"PGW-AFT model","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"\n# Construct the model directly (no optimization)\nmodel = AcceleratedFaillureTime(\n    zeros(n), trues(n), PowerGeneralizedWeibull(theta0...),\n    des, zeros(n,0),  # X2 is empty for AFT\n    zeros(0), beta0\n)\n\n# Simulate event times\nsimdat = simGH(n, model)\n\n# Censoring\ncens = 10\nstatus = simdat .< cens\nsimdat = min.(simdat, cens)\n\ndf = DataFrame(time=simdat, status=status, x1=des[:,1], x2=des[:,2])\nmodel = fit(AcceleratedFaillureTime{PowerGeneralizedWeibull}, \n    @formula(Surv(time, status) ~ x1 + x2), df)\n\nresult = DataFrame(\n    Parameter = [\"θ₁\", \"θ₂\", \"θ₃\", \"β₁\", \"β₂\"],\n    True      = vcat(theta0, beta0),\n    Fitted    = vcat(params(model.baseline)..., model.β)\n)","category":"page"},{"location":"parametric/generalhazard/#PGW-AH-model","page":"General Hazard","title":"PGW-AH model","text":"","category":"section"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"# Construct the model directly (no optimization)\nmodel = AcceleratedHazard(zeros(n), trues(n), \n    PowerGeneralizedWeibull(theta0...),\n    zeros(n,0), des_t,  # X1 is empty for AH\n    alpha0, zeros(0)\n)\n\n# Simulate event times\nsimdat = simGH(n, model)\ncens = 10\nstatus = simdat .< cens\nsimdat = min.(simdat, cens)\n\ndf = DataFrame(time=simdat, status=status, z1=des_t[:,1], z2=des_t[:,2])\nmodel = fit(AcceleratedHazard{PowerGeneralizedWeibull}, \n    @formula(Surv(time, status) ~ z1 + z2), df)\n\nresult = DataFrame(\n    Parameter = [\"θ₁\", \"θ₂\", \"θ₃\", \"α₁\", \"α₂\"],\n    True      = vcat(theta0, alpha0),\n    Fitted    = vcat(params(model.baseline)..., model.α)\n)","category":"page"},{"location":"parametric/generalhazard/","page":"General Hazard","title":"General Hazard","text":"Y. Chen and N. Jewell. On a general class of semiparametric hazards regression models. Biometrika 88, 687–702 (2001).\n\n\n\nF. Rubio, L. Remontet, N. Jewell and A. Belot. On a general structure for hazard-based regression models: an application to population-based cancer research. Statistical Methods in Medical Research 28, 2404–2417 (2019).\n\n\n\nJ. Kalbfleisch and R. Prentice. The statistical analysis of failure time data (John Wiley & Sons, 2011).\n\n\n\nD. Cox. Regression models and life-tables. Journal of the Royal Statistical Society: Series B (Methodological) 34, 187–202 (1972).\n\n\n\nY. Chen and M. Wang. Analysis of accelerated hazards models. Journal of the American Statistical Association 95, 608–618 (2000).\n\n\n\n","category":"page"},{"location":"nonparametric/logranktest/#Log-Rank-Test","page":"Log-Rank Test","title":"Log-Rank Test","text":"","category":"section"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"The log-rank test [3] is a non-parametric test to compare the survival distributions of two or more groups. It can be stratified to account for baseline differences.","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"Suppose we have G groups. At each event time t_j:","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"d_gj: number of events in group g at t_j\nY_gj: number at risk in group g just before t_j\nd_j = sum_g d_gj: total events at t_j\nY_j = sum_g Y_gj: total at risk at t_j","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"The expected number of events in group g at t_j under the null hypothesis is:","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"E_gj = Y_gj fracd_jY_j","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"The log-rank test statistic is:","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"Z_g = sum_j (d_gj - E_gj)","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"For two groups, the test statistic is:","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"Z = fracleftsum_j (d_1j - E_1j)right^2sum_j V_1j","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"where","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"V_1j = fracY_1j Y_2j d_j (Y_j - d_j)Y_j^2 (Y_j - 1)","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"Under the null hypothesis, Z is approximately chi-squared distributed with G-1 degrees of freedom.","category":"page"},{"location":"nonparametric/logranktest/#Stratified-Log-Rank-Test","page":"Log-Rank Test","title":"Stratified Log-Rank Test","text":"","category":"section"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"If there are stratas, the test statistic and variance are summed over strata.","category":"page"},{"location":"nonparametric/logranktest/#Usage","page":"Log-Rank Test","title":"Usage","text":"","category":"section"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"You can compute a log-rank test using the following code: ","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"using SurvivalModels\n\nT = [1, 2, 3, 4, 1, 2, 3, 4]\nΔ = [1, 1, 1, 1, 1, 1, 1, 1]\ngroup = [1, 1, 2, 2, 1, 1, 2, 2]\nstrata = [1, 1, 1, 1, 2, 2, 2, 2]\nlrt = LogRankTest(T, Δ, group, strata)","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"and/or with the formula interface: ","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"using DataFrames\ndf = DataFrame(time=T, status=Δ, group=group, strata=strata)\nlrt2 = fit(LogRankTest, @formula(Surv(time, status) ~ Strata(strata) + group), df)","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"The produced object has the following fields: ","category":"page"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"stat: Chi-square test statistic.\ndf: Degrees of freedom.\npval: P-value of the test.","category":"page"},{"location":"nonparametric/logranktest/#References","page":"Log-Rank Test","title":"References","text":"","category":"section"},{"location":"nonparametric/logranktest/#SurvivalModels.LogRankTest","page":"Log-Rank Test","title":"SurvivalModels.LogRankTest","text":"LogRankTest(T, Δ, group, strata)\nfit(LogRankTest, @formula(Surv(T, Δ) ~ gr), data = ...)\nfit(LogRankTest, @formula(Surv(T, Δ) ~ Strata(st) + gr), data = ...)\n\nPerforms the stratified log-rank test for comparing survival distributions across groups.\n\nArguments\n\nT: Vector of observed times.\nΔ: Vector of event indicators (1 = event, 0 = censored).\ngroup: Vector indicating group membership (e.g., treatment arm).\nstrata: Vector indicating strata membership (e.g., baseline strata).\ngr and st are the variables in the DataFrame defining the groups and strata for the fit interface.\n\nReturns\n\nA LogRankTest object with the following fields:\n\nstat: Chi-square test statistic.\ndf: Degrees of freedom (number of groups minus 1).\npval: P-value of the test.\n\nNotes\n\nImplements the stratified log-rank test by aggregating test statistics and variances over strata.\nSuitable for right-censored survival data with stratification.\n\n\n\n\n\n","category":"type"},{"location":"nonparametric/logranktest/","page":"Log-Rank Test","title":"Log-Rank Test","text":"N. Mantel. Evaluation of survival data and two new rank order statistics arising in its consideration. Cancer chemotherapy reports 50, 163–170 (1966).\n\n\n\n","category":"page"},{"location":"nonparametric/kaplanmeier/#Kaplan-Meier-Estimator","page":"Kaplan-Meier","title":"Kaplan-Meier Estimator","text":"","category":"section"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"The Kaplan-Meier estimator[1] is a non-parametric statistic used to estimate the survival function from lifetime data, especially when data are censored. The Greenwood formula [2] is used for variance estimation.","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"Suppose we observe n individuals, with observed times T_1 T_2 ldots T_n and event indicators Delta_1 Delta_2 ldots Delta_n (Delta_i = 1 if the event occurred, 0 if censored).","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"Let t_1  t_2  cdots  t_k be the ordered unique event times, and set: ","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"d_j: number of events at time t_j\nn_j: number of individuals at risk just before t_j","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"The Kaplan-Meier estimator of the survival function S(t) is:","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"hatS(t) = prod_t_j leq t left(1 - fracd_jn_jright)","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"This product runs over all event times t_j less than or equal to t.","category":"page"},{"location":"nonparametric/kaplanmeier/#Greenwood's-Formula","page":"Kaplan-Meier","title":"Greenwood's Formula","text":"","category":"section"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"The Greenwood estimator [2] for the variance of hatS(t) is:","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"widehatmathrmVarhatS(t) = hatS(t)^2 sum_t_j leq t fracd_jn_j (n_j - d_j)","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"This allows for the construction of confidence intervals for the survival curve.","category":"page"},{"location":"nonparametric/kaplanmeier/#How-to-use-it","page":"Kaplan-Meier","title":"How to use it","text":"","category":"section"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"You can compute these estimators using the following code: ","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"using SurvivalModels\n\nT = [2, 3, 4, 5, 8]\nΔ = [1, 1, 0, 1, 0]\nkm = KaplanMeier(T, Δ)","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"and/or with the formula interface: ","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"using DataFrames\ndf = DataFrame(time=Float64.(T), status=Bool.(Δ))\nkm = fit(KaplanMeier, @formula(Surv(time, status) ~ 1), df)","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"The obtained objects has the following fields: ","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"t: Sorted unique event times.\n∂N: Number of uncensored deaths at each time point.\nY: Number of individuals at risk at each time point.\n∂Λ: Increments of cumulative hazard.\n∂σ: Greenwood variance increments.","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"The obtained object can be used to compute survival and variance estimates as follows: ","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"using SurvivalModels: greenwood\nŜ = km(5.0)  # Survival probability at time 5\nv̂ = greenwood(km, 5.0)  # Greenwood variance at time 5\nŜ, v̂","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"Finally, a (1-alpha) times 100 confidence interval for S(t) can be constructed using the log-minus-log transformation:","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"log(-log hatS(t)) pm z_1-alpha2 frac1log hatS(t) sqrtwidehatmathrmVarhatS(t)","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"The confint function can do it for you: ","category":"page"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"using SurvivalModels\n\nT = [2, 3, 4, 5, 8]\nΔ = [1, 1, 0, 1, 0]\nkm = KaplanMeier(T, Δ)\n\n# Compute confidence intervals at each event time (default 95%)\nci = confint(km)\nfirst(ci, 5)  # show the first 5 rows","category":"page"},{"location":"nonparametric/kaplanmeier/#References","page":"Kaplan-Meier","title":"References","text":"","category":"section"},{"location":"nonparametric/kaplanmeier/#SurvivalModels.KaplanMeier","page":"Kaplan-Meier","title":"SurvivalModels.KaplanMeier","text":"KaplanMeier(T, Δ)\nfit(KaplanMeier, @formula(Surv(T, Δ) ~ 1), df)\n\nEfficient Kaplan-Meier estimator.\n\nMathematical Description\n\nSuppose we observe n individuals, with observed times T_1 T_2 ldots T_n and event indicators Delta_1 Delta_2 ldots Delta_n (Delta_i = 1 if the event occurred, 0 if censored).\n\nLet t_1  t_2  cdots  t_k be the ordered unique event times.\n\nd_j: number of events at time t_j\nY_j: number of individuals at risk just before t_j\n\nThe Kaplan-Meier estimator of the survival function S(t) is:\n\nhatS(t) = prod_t_j leq t left(1 - fracd_jY_jright)\n\nThis product runs over all event times t_j less than or equal to t.\n\nThe Greenwood estimator for the variance of hatS(t) is:\n\nwidehatmathrmVarhatS(t) = hatS(t)^2 sum_t_j leq t fracd_jY_j (Y_j - d_j)\n\nArguments\n\nT: Vector of event or censoring times.\nΔ: Event indicator vector (1 if event, 0 if censored).\n\nStores\n\nt: Sorted unique event times.\n∂N: Number of uncensored deaths at each time point.\nY: Number of at risk individuals at each time point.\n∂Λ: Increments of cumulative hazard.\n∂σ: Greenwood variance increments.\n\nExample: Direct usage\n\nusing SurvivalModels\nT = [2, 3, 4, 5, 8]\nΔ = [1, 1, 0, 1, 0]\nkm = KaplanMeier(T, Δ)\n\nExample: Using the fit() interface\n\nusing SurvivalModels, DataFrames, StatsModels\ndf = DataFrame(time=T, status=Δ)\nkm2 = fit(KaplanMeier, @formula(Surv(time, status) ~ 1), df)\n\n\n\n\n\n","category":"type"},{"location":"nonparametric/kaplanmeier/#SurvivalModels.greenwood","page":"Kaplan-Meier","title":"SurvivalModels.greenwood","text":"greenwood(S::KaplanMeier, t)\n\nCompute the Greenwood variance estimate for the Kaplan-Meier survival estimator at time t.\n\nThe Greenwood formula provides an estimate of the variance of the Kaplan-Meier survival function at a given time point. For a fitted Kaplan-Meier object S, the variance at time t is:\n\n```math \\widehat{\\mathrm{Var}}[\\hat{S}(t)] = \\hat{S}(t)^2 \\sum{tj < t} \\frac{dj}{Yj (Yj - dj)}\n\n\n\n\n\n","category":"function"},{"location":"nonparametric/kaplanmeier/","page":"Kaplan-Meier","title":"Kaplan-Meier","text":"E. L. Kaplan and P. Meier. Nonparametric estimation from incomplete observations. Journal of the American statistical association 53, 457–481 (1958).\n\n\n\nM. Greenwood. The natural duration of cancer. Reports on Public Health and Medical Subjects 33, 1–26 (1926).\n\n\n\n","category":"page"},{"location":"semiparametric/cox/#Cox-models","page":"Cox","title":"Cox models","text":"","category":"section"},{"location":"semiparametric/cox/#The-Cox-Proportional-Hazards-Model:-Theory","page":"Cox","title":"The Cox Proportional Hazards Model: Theory","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The Cox Proportional Hazards Model [4] is a semi-parametric model used to analyze time-to-event data. It models the relationship between the survival time of an individual and a set of explanatory variables (covariates). ","category":"page"},{"location":"semiparametric/cox/#1.-The-Hazard-Function","page":"Cox","title":"1. The Hazard Function","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The model is defined by the hazard function, which describes the risk of an event occuring at time t, given that the event has not occured before the time t. The hazard function is given by:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"h(t  mathbfX) = h_0(t) exp(mathbfX^Tmathbfbeta)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"where:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"h_0(t) is the baseline hazard function. This is an unspecified, non-negative function of time that represents the hazard for an individual with all covariates equal to zero. It captures the underlying risk profile common to all individuals.\nmathbfX is the covariate vector for an individual. These are the independent variables (e.g., age, treatment, gender) that influence the event time.\nmathbfbeta is the vector of regression coefficients.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The term exp(mathbfX^Tmathbfbeta) is often called the hazard ratio.","category":"page"},{"location":"semiparametric/cox/#2.-The-Survival-Function","page":"Cox","title":"2. The Survival Function","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The survival function, S(t), which represents the probability that an individual survives beyond time t.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"S(t  mathbfX) = expleft(-int_0^t h(u  mathbfX) duright)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"After substituting the Cox hazard function:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"S(t  mathbfX) = expleft(-exp(mathbfX^top boldsymbolbeta) int_0^t h_0(u) duright)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"with H_0(t) = int_0^t h_0(u) du","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"Finally, ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"S(t  mathbfX) = expleft(-exp(mathbfX^top boldsymbolbeta) H_0(t)right)","category":"page"},{"location":"semiparametric/cox/#3.-The-Full-Likelihood-Function","page":"Cox","title":"3. The Full Likelihood Function","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The full likelihood function includes the baseline hazard:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"L(boldsymbolbeta h_0(cdot)) = prod_i=1^n left( h(t_i  mathbfX_i) right)^Delta_i S(t_i  mathbfX_i)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"with:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"h(t_i  mathbfX_i) for the individuals at risk of the event at time t_i(Delta_i=1)\nS(t_i  mathbfX_i) for the individuals censored at time t_i(Delta_i=0)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"And if we substitute the hazard and survival function:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"L(boldsymbolbeta h_0(cdot)) = prod_i=1^n left( h_0(t_i) exp(mathbfX_i^top boldsymbolbeta) right)^Delta_i expleft(-exp(mathbfX_i^top boldsymbolbeta) H_0(t_i)right)","category":"page"},{"location":"semiparametric/cox/#4.-The-Partial-Likelihood-Function","page":"Cox","title":"4. The Partial-Likelihood Function","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"Since the baseline hazard function h_0(t) is unspecified, a standard likelihood function cannot be formed directly. Instead, Cox introduced the concept of a partial likelihood. This approach focuses on the order of events rather than their exact timings, factoring out the unknown h_0(t).","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"For each distinct observed event time t_(j), we consider the set of individuals who are \"at risk\" of experiencing the event just before t_(j). This is called the risk set, R(t_(j)). The partial likelihood is constructed by considering the probability that the specific individual(s) who experienced the event at t_(j) were the ones to fail, given that some event occurred among the individuals in R(t_(j)).","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The partial-likelihood function for the Cox model, accounting for tied event times using Breslow's approximation, is given by:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"L(mathbfbeta) = prod_j=1^k left( fracexp(mathbfX_i^Tmathbfbeta) sum_l in R_j exp(mathbfX_l^Tmathbfbeta)right)^Delta_i","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"where:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"k is the number of distinct event times.\nt_(j) denotes the j-th distinct ordered event time.\nDelta_j is the set of individuals who experience the event at time t_(j).\nR_j is the risk set at time t_(j), comprising all individuals who are still at risk (have not yet experienced the event or been censored) just- before t_(j).\nmathbfX_i is the covariate vector for individual i.","category":"page"},{"location":"semiparametric/cox/#5.-The-Loss-Function-(Negative-Log-Partial-Likelihood)","page":"Cox","title":"5. The Loss Function (Negative Log-Partial-Likelihood)","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"Our goal is to estimate the regression coefficients mathbfbeta by maximizing the partial-likelihood function L(mathbfbeta). Equivalently, it is often more convenient to minimize its negative logarithm, which we define as our loss function:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"textLoss(mathbfbeta) = - log L(mathbfbeta) ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"Taking the negative logarithm of the Breslow partial likelihood, we get:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"\ntextLoss(mathbfbeta) = - sum_i=1^n Delta_i left( mathbfX_i^Tmathbfbeta - log left( sum_j in R_j exp(mathbfX_j^Tmathbfbeta) right) right)\n","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"This function is convex, which facilitates optimization.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The loss function is coded as follows: ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"function loss(beta, M::Cox)\n    # M.X: Design matrix (n x m), where n is number of observations, m is number of covariates.\n    # M.T: Vector of observed times (n) for each individual.\n    # M.Δ: Vector of event indicators (n), 1 if event, 0 if censored.\n    η = M.X*beta\n    return dot(M.Δ, log.((M.T .<= M.T') * exp.(η)) .- η)\nend","category":"page"},{"location":"semiparametric/cox/#6.-Gradient-of-the-Loss-Function","page":"Cox","title":"6. Gradient of the Loss Function","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"To find the optimal mathbfbeta, we need to minimize the loss function. ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The gradient of the loss function with respect to a specific coefficient beta_k is:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"fracpartialpartial beta_k textLoss(mathbfbeta) = - sum_i=1^n left( X_ik - fracsum_j in R_i exp(mathbfbeta^TmathbfX_j) X_jksum_j in R_i exp(mathbfbeta^TmathbfX_j) right)","category":"page"},{"location":"semiparametric/cox/#7.-Hessian-Matrix-of-the-Loss-Function","page":"Cox","title":"7. Hessian Matrix of the Loss Function","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"For optimization algorithms like Newton-Raphson and for calculating standard errors, the Hessian matrix (matrix of second partial derivatives) of the loss function is required.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The entry for the k-th row and l-th column of the Hessian matrix is:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"fracpartial^2partial beta_k partial beta_l textLoss(mathbfbeta) = sum_i=1^n Delta_i left fracsum_j in R_i exp(mathbfbeta^TmathbfX_j) X_jkX_jlsum_j in R_i exp(mathbfbeta^TmathbfX_j) - fracleft( sum_j in R_i exp(mathbfbeta^TmathbfX_j) X_jk right) left( sum_j in R_i exp(mathbfbeta^TmathbfX_j) X_jl right)left( sum_j in R_i exp(mathbfbeta^TmathbfX_j) right)^2 right","category":"page"},{"location":"semiparametric/cox/#8.-Information-Matrix-and-Variance-Covariance-Matrix","page":"Cox","title":"8. Information Matrix and Variance-Covariance Matrix","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The observed Information Matrix, I(hatboldsymbolbeta), is defined as the negative of the Hessian matrix of the log-likelihood function, evaluated at the maximum likelihood estimates hatboldsymbolbeta.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"I(hatboldsymbolbeta) = -H(hatboldsymbolbeta)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"But, in the earlier formula, mathbfH_textLoss​ was for Loss(β), which is -log L(β) mathbfH_textLoss = - mathbfH_textlog-likelihood. Therefore, the observed Information Matrix is equal to mathbfH_textLoss itself.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The variance (and covariance) of our estimators hatboldsymbolbeta are obtained by inverting the observed information matrix.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"textVar(hatboldsymbolbeta) = I(hatboldsymbolbeta)^-1","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"This final matrix contains:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"On its diagonal: the variances of each coefficient (textVar(hatbeta_1), textVar(hatbeta_2), ...).\nOff-diagonal: the covariances between pairs of coefficients.","category":"page"},{"location":"semiparametric/cox/#9.-Standard-Error","page":"Cox","title":"9. Standard Error","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The standard error for a specific coefficient (hatbeta_k) is the square root of its variance.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"SE(hatbeta_k) = sqrttextVar(hatbeta_k)","category":"page"},{"location":"semiparametric/cox/#10.-Wald-Test-for-Significance","page":"Cox","title":"10. Wald Test for Significance","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"To determine if a variable has a statistically significant effect, a Wald test is performed. A z-score is calculated:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"z = fractextCoefficienttextErreur Type = frachatbetaSE(hatbeta)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"This z-score is then compared to a normal distribution to obtain a p-value. A low p-value (typically < 0.05) suggests that the coefficient is significantly different from zero.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The p-value for each coefficient is calculated by comparing its z-score to a standard normal distribution. This p-value indicates the probability of observing a z-score as extreme as, or more extreme than, the one calculated, assuming the null hypothesis (that the coefficient is zero) is true.","category":"page"},{"location":"semiparametric/cox/#11.-Confidence-Interval","page":"Cox","title":"11. Confidence Interval","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The standard error allows for the construction of a confidence interval (CI) around the coefficient, which provides a range of plausible values for the true coefficient.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The general formula for a (1 - alpha) times 100 confidence interval is:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"textIC pour  hatbeta = hatbeta pm z_alpha2 times SE(hatbeta)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"Let us see for example the output on the colon dataset: ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"using SurvivalModels\nusing RDatasets\n\n# ovarian = dataset(\"survival\", \"ovarian\")\n# ovarian.FUTime = Float64.(ovarian.FUTime)\n# ovarian.FUStat = Bool.(ovarian.FUStat)\n# model = fit(Cox, @formula(Surv(FUTime, FUStat) ~ Age + ECOG_PS), ovarian)\n\ncolon = dataset(\"survival\", \"colon\")\ncolon.Time = Float64.(colon.Time)\ncolon.Status = Bool.(colon.Status)\nmodel_colon = fit(Cox, @formula(Surv(Time, Status) ~ Age + Rx), colon)\n","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The outputed dataframe contains columns with respectively the name of the predictor, the obtained coefficients, its standard error, the associated p-value and the test statistic z as just described. ","category":"page"},{"location":"semiparametric/cox/#SurvivalModels.Cox","page":"Cox","title":"SurvivalModels.Cox","text":"StatsBase.fit(Cox, @formula(Surv(T,Δ)~predictors), dataset)\n\nArguments: \n\nT: The Cox model type to fit (CoxV3)\nformula: A StatsModels.FormulaTerm specifying the survival model\ndf: A DataFrame containing the variables specified in the formula\n\nReturns: \n\npredictor: A Vector{String} containing the names of the predictor variables included in the model\nbeta: A Vector{Float64} containing the estimated regression coefficients (β​) for each predictor\nse: A Vector{Float64} containing the standard errors of the estimated regression coefficients\nloglikelihood: A Vector{Float64} containing the log-likelihood of the fitted model. This value is repeated for each predictor row \ncoef: A vector of the estimated coefficients\nformula: The applied formula\n\nExample:\n\novarian = dataset(\"survival\", \"ovarian\")\novarian.FUTime = Float64.(ovarian.FUTime) (Time column needs to be Float64 type)\novarian.FUStat = Bool.(ovarian.FUStat) (Status column needs to be Bool type)\nmodel = fit(Cox, @formula(Surv(FUTime, FUStat) ~ Age + ECOG_PS), ovarian)\n\nTypes: \n\nCox : the base abstract type\nCoxGrad<:Cox : abstract type for Cox models that are solved using gradient-based optimization\nCoxLLH<:CoxGrad : abstract type for Cox models that are solved by optimizing the log-likelihood\n\n\n\n\n\n","category":"type"},{"location":"semiparametric/cox/#Different-versions-of-the-optimisation-routine","page":"Cox","title":"Different versions of the optimisation routine","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"To implement the Cox proportional hazards model, different versions were coded, using different methods. The final goal is to compare these versions and choose the most efficient one: the fastest and the closest to the true values of the coefficients. ","category":"page"},{"location":"semiparametric/cox/#V0:-Derivative-Free-Optimization-with-Nelder-Mead","page":"Cox","title":"V0: Derivative-Free Optimization with Nelder-Mead","text":"","category":"section"},{"location":"semiparametric/cox/#SurvivalModels.CoxV0","page":"Cox","title":"SurvivalModels.CoxV0","text":"CoxVO(T, Δ, X)\nfit(CoxV0, @formula(Surv(T,Δ)~X), data = ...)\n\nAn implementation of the Cox proportional hazards model that minimizes the negative partial log-likelihood function (cox_nllh). This version uses the Nelder-Mead method, a derivative-free optimization algorithm. \n\nFields: \n\nX::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features\nT::Vector{Float64}: The observed times, sorted in ascending order \nΔ::Vector{Bool}: The event indicator vector (true for event, false for censoring)\n\n\n\n\n\n","category":"type"},{"location":"semiparametric/cox/#V1:-Implementation-using-the-'Optimization.jl'-Julia-package","page":"Cox","title":"V1: Implementation using the 'Optimization.jl' Julia package","text":"","category":"section"},{"location":"semiparametric/cox/#SurvivalModels.CoxV1","page":"Cox","title":"SurvivalModels.CoxV1","text":"CoxV1(T, Δ, X)\nfit(CoxV1, @formula(Surv(T,Δ)~X), data = ...)\n\nThe first implementation of the Cox proportional hazards model uses optimization libraries (Optimization.jl, Optim.jl) for coefficient estimation. It uses the BFGS algorithm to minimize the negative partial log-likelihood. \n\nFields: \n\nX::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features.\nT::Vector{Float64}: The observed times, sorted in ascending order\nΔ::Vector{Int64}: The event indicator vector (true for event, false for censoring)\n\n\n\n\n\n","category":"type"},{"location":"semiparametric/cox/#V2:-Implementation-using-the-gradient-and-the-Hessian-matrix","page":"Cox","title":"V2: Implementation using the gradient and the Hessian matrix","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"For this version the Hessian Matrix was directly implemented. Its complexity is O(n2m2) which makes it the slowest version.","category":"page"},{"location":"semiparametric/cox/#SurvivalModels.CoxV2","page":"Cox","title":"SurvivalModels.CoxV2","text":"CoxV2(T, Δ, X)\nfit(CoxV2, @formula(Surv(T,Δ)~X), data = ...)\n\nThe second implementation of the Cox proportional hazards model uses a Newton-Raphson-like iterative update that directly calculates and utilizes the gradient and Hessian matrix. This version is updating coefficients via the update! function.\n\nFields:\n\nX::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features\nT::Vector{Float64}: The observed times, sorted in ascending order\nΔ::Vector{Int64}: The event indicator vector (true for event, false for censoring)\nR::BitMatrix: A boolean risk matrix, where 'R[i,j]' is 'true' if individual 'j' is at risk at time 'T[i]'\n\n\n\n\n\n","category":"type"},{"location":"semiparametric/cox/#V3:-Improved-version-of-V2-(much-faster)-because-non-allocative.","page":"Cox","title":"V3: Improved version of V2 (much faster) because non-allocative.","text":"","category":"section"},{"location":"semiparametric/cox/#SurvivalModels.CoxV3","page":"Cox","title":"SurvivalModels.CoxV3","text":"CoxV3(T, Δ, X)\nfit(CoxV3, @formula(Surv(T,Δ)~X), data = ...)\nfit(Cox, @formula(Surv(T,Δ)~X), data = ...)\n\nThe third implementation of the Cox proportional hazards model represents a highly optimized and significantly faster iteration compared to previous implementation, CoxV2.\n\nThis is the default implementation called when you ask for a Cox model. \n\nFields:\n\nXᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)\nsX::Vector{Float64}: Sum of X' multiplied by Δ\nT::Vector{Float64}: The observed times sorted in descending order\nΔ::Vector{Bool}: The event indicator vector (true for event, false for censoring)\nloss::Vector{Float64}: Stores the current negative partial log-likelihood value\nG::Vector{Float64}: Stores the gradient vector  \nH::Matrix{Float64}: Stores the Hessian matrix \nS₁::Vector{Float64}: Sum of rⱼxₖⱼ\nS₂::Matrix{Float64}: Sum of rⱼxₖⱼ * xⱼ\nμ::Vector{Float64}: Updates the gradient and Hessian\nη::Vector{Float64}: ηi = Xiβ\nr::Vector{Float64}: ri = exp(ηi)\nR::Vector{UnitRange{Int64}}: A vector of the risk ranges for each output time.\n\n\n\n\n\n","category":"type"},{"location":"semiparametric/cox/#V4:-Majoration-of-the-Hessian-matrix-by-a-universal-bound.","page":"Cox","title":"V4: Majoration of the Hessian matrix by a universal bound.","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"Coding the Hessian Matrix for the CoxV2 was very impratical, so for this version we tried a different approach: ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The Hessian Matrix simplifies for the diagonal terms as folllows: ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"fracpartial^2 textLoss(mathbfbeta)partial beta_k^2 = sum_i=1^n Delta_i left fracsum_j in R_i exp(mathbfbeta^TmathbfX_j) X_jk^2sum_j in R_i exp(mathbfbeta^TmathbfX_j) - left( fracsum_j in R_i exp(mathbfbeta^TmathbfX_j) X_jksum_j in R_i exp(mathbfbeta^TmathbfX_j) right)^2 right","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"This can be expressed using the concept of variance. ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"fracpartial^2 textLoss(mathbfbeta)partial beta_k^2 = sum_i=1^n Delta_i left sum_j in R_i A_j X_jk^2 - left( sum_j in R_i A_j X_jk right)^2 right","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"with:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"A_j = fracexp(mathbfbeta^TmathbfX_j)sum_j in R_i exp(mathbfbeta^TmathbfX_j)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The upper bound for the variance of a variable X on an interval ab is given by:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"textVar(X) le frac14(b-a)^2","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"Applying this bound to the diagonal Hessian elements, we get an approximation for the k-th diagonal element, B_k:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"B_k = sum_i=1^n frac14 Delta_i left( max_j in R_i X_jk - min_j in R_i X_jk right)^2","category":"page"},{"location":"semiparametric/cox/#SurvivalModels.CoxV4","page":"Cox","title":"SurvivalModels.CoxV4","text":"CoxV4(T, Δ, X)\nfit(CoxV4, @formula(Surv(T,Δ)~X), data = ...)\n\nThe fourth implementation of the Cox proportional hazards model uses Hessian approximation based on a pre-calculated estimation. This version was created for when it might be difficult to work with full Hessian , offering faster iterations by using a Hessian approximation.\n\nFields:\n\nX::Matrix{Float64}: The design matrix of covariates, where rows correspond to individuals and columns to features\nT::Vector{Float64}: The observed times sorted in ascending order\nΔ::Vector{Bool}: The event indicator vector (true for event, false for censoring)\nsX::Vector{Float64}: Sum of X' multiplied by Δ\nG::Vector{Float64}: Stores the gradient vector\nη::Vector{Float64}: ηi = Xiβ\nA::Vector{Float64}: Ai = exp(ηi)\nB::Vector{Float64}: Stores the majoration elements of the Hessian matrix\nC::Vector{Float64}: Used in the mkA! function\nK::Vector{Int64}: Number of events at each unique observed event time\nloss::Vector{Float64}: Stores the current negative partial log-likelihood value, used in CoxLLH getβ\n\n\n\n\n\n","category":"type"},{"location":"semiparametric/cox/#V5","page":"Cox","title":"V5","text":"","category":"section"},{"location":"semiparametric/cox/#SurvivalModels.CoxV5","page":"Cox","title":"SurvivalModels.CoxV5","text":"CoxV5(T, Δ, X)\nfit(CoxV5, @formula(Surv(T,Δ)~X), data = ...)\n\nThe fifth implementation of the Cox proportional hazards model uses a pre-calculated Hessian approximation for faster iterations, like CoxV4. Its approach is similar to CoxV3.\n\nFields:\n\nXᵗ::Matrix{Float64}: The design matrix of covariates, transposed (m rows, n columns)\nsX::Vector{Float64}: Sum of X' multiplied by Δ\nT::Vector{Float64}: The observed times sorted in descending order\nΔ::Vector{Bool}: The event indicator vector (true for event, false for censoring)\nloss::Vector{Float64}: Stores the current negative partial log-likelihood value\nG::Vector{Float64}: Stores the gradient vector.\nS₁::Vector{Float64}:  Sum of rⱼxₖⱼ\nμ::Vector{Float64}: Currently unused in update! function\nη::Vector{Float64}: ηi = Xiβ\nr::Vector{Float64}: ri = exp(ηi)\nR::Vector{UnitRange{Int64}}:\nB::Vector{Float64}: Stores the majoration elements of the Hessian matrix\n\n\n\n\n\n","category":"type"},{"location":"semiparametric/cox/#Comparison-of-the-different-methods-speed","page":"Cox","title":"Comparison of the different methods speed","text":"","category":"section"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"We propose to compare the different methods on simulated data, with varying number of lines and columns, to verify empirically the theoretical complexity of the different methods.  We will then compare the results with Julia's and R's existing Cox implementation.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"We will start by coding our Julia and R structures: ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"using SurvivalModels, Plots, Random, Distributions, StatsBase, LinearAlgebra, DataFrames, RCall, Survival\nusing SurvivalModels: getβ, CoxV0, CoxV1, CoxV2, CoxV3, CoxV4, CoxV5","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"We add specific code to compare with Survival.jl and also R::survival::coxph():","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"struct CoxVJ\n    T::Vector{Float64}\n    Δ::Vector{Bool}\n    X::Matrix{Float64}\n    function CoxVJ(T,Δ,X)\n        new(T,Bool.(Δ),X)\n    end\nend\n\nfunction SurvivalModels.getβ(M::CoxVJ)\n    return fit(Survival.CoxModel, M.X, Survival.EventTime.(M.T,M.Δ)).β\nend\n\nR\"\"\"\nlibrary(survival)\n\"\"\"\n\nstruct CoxVR\n    df::DataFrame\n    function CoxVR(T,Δ,X)\n        df = DataFrame(X,:auto)\n        df.status = Δ\n        df.time = T\n        new(df)\n    end\nend\n\nfunction SurvivalModels.getβ(M::CoxVR)\n    df = M.df\n    @rput df\n    R\"\"\"\n    beta  <- coxph(Surv(time,status)~., data = df, ties=\"breslow\")$coefficients\n    \"\"\"\n    @rget beta\n    return beta\nend","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"Then, we will simulate our data and then run our models:","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"# Creating a dictionary for all the models:\n# Label => (constructor, plotting color)\n\nconst design = Dict(\n\"V0\"=> (CoxV0, :blue),\n\"V1\"=> (CoxV1, :orange),\n\"V2\"=> (CoxV2, :brown),\n\"V3\"=> (CoxV3, :purple),\n\"V4\"=> (CoxV4, :green),\n\"V5\"=> (CoxV5, :yellow),\n\"VR\"=> (CoxVR, :red),\n\"VJ\"=> (CoxVJ, :black)\n);\n\n\nfunction simulate_survival_data(n, m; β=ones(m)) \n    X = randn(n,m)\n    O = rand.(Exponential.(exp.(.- X * β)))\n    C = rand(Exponential(1/3),n)\n    T = min.(O, C)\n    Δ = Bool.(O .<= C) \n    return (T, Δ, X)\nend\n\n# Run the models and get the running time, the β coefficients and the difference between the true β and the obtained ones: \nfunction run_models() \n    Ns = (1000, 2000, 4000) \n    Ms = (5,10,20)\n    true_betas = randn(maximum(Ms))\n    df = []\n    for n in Ns, m in Ms\n        if (n == 2000) | (m == 10) # Only if they end up in the graphs.\n            data = simulate_survival_data(n,m, β = true_betas[1:m])\n            for (name, (constructor, _)) in design\n                display((n,m,name))\n                model = constructor(data...)\n                beta = getβ(model)\n                time = @elapsed getβ(model)\n                push!(df, (\n                    n = n, \n                    m = m, \n                    name = name, \n                    time = time,\n                    beta = beta,\n                    diff_to_truth = sqrt(sum((beta .- true_betas[1:m]).^2)/sum(true_betas[1:m].^2)),\n                ))\n            end\n        end\n    end\n    df = DataFrame(df)\n    sort!(df, :name)\n    return df\nend","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"The first graph will compare how long it takes for all the implementations to run on datasets that have maximum 2000 observations and 20 covariates.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"# Plot the results, starting with the time: \nfunction timing_graph(df)\n    group1 = groupby(filter(r -> r.m==10, df), :name)\n    p1 = plot(; xlabel = \"Number of observations (n)\",\n        ylabel = \"Time (in seconds)\",\n        yscale= :log10,\n        xscale= :log10,\n        title = \"For m=20 covs., varying n\",\n        legend = :bottomright,\n        lw = 1);\n    for g in group1\n        plot!(p1, g.n, g.time, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n    end\n    group2 = groupby(filter(r -> r.n==2000, df), :name)\n        p2 = plot(; xlabel = \"Number of covariates (m)\",\n            ylabel = \"Temps (ms)\",\n            yscale= :log10,\n            xscale= :log10,\n            title = \"For n=2000 obs., varying m\",\n            legend = :bottomright,\n            lw = 1);\n        for g in group2\n            plot!(p2, g.m, g.time, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n        end\n        p = plot(p1,p2, size=(1200,600), plot_title = \"Runtime (logscale) of the various implementations\")\n        return p\nend","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"df = run_models()\ntiming_graph(df)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"We can the that CoxV3 is the fastest, while CoxV2 is the slowest. We will zoom on our implementation vs Survival.jl vs R::survival: ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"timing_graph(filter(r -> r.name ∈ (\"V4\", \"V3\", \"VJ\", \"VR\"), df))","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"So we are about x10 faster than the reference implementation of R (and than the previous Julia versions) on this example. ","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"function beta_correctness_graphs(df; ref=\"VJ\")\n    \n    reflines = filter(r -> r.name == ref, df)\n    rename!(reflines, :beta => :refbeta)\n    select!(reflines, Not([:name, :time, :diff_to_truth]))\n    otherlines = filter(r -> r.name != ref, df)\n    rez = leftjoin(otherlines, reflines, on=[:n,:m])\n    percent(x,y) = sqrt(sum((x .- y).^2)/sum(y .^2))\n    rez.error = percent.(rez.beta, rez.refbeta)\n    select!(rez, [:n,:m,:name,:error])\n    rez = filter!(r -> !isnan(r.error), rez)\n    \n    group1 = groupby(filter(r -> r.m==20, rez), :name)\n    p1 = plot(; xlabel = \"Number of observations (n)\",\n                ylabel = \"L2dist to $ref's β\",\n                yscale=:log10,\n                xscale= :log10,\n                title = \"m=20, varying n\",\n                legend = :bottomright,\n                lw = 1);\n    for g in group1\n        plot!(p1, g.n, g.error, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n    end\n\n    group2 = groupby(filter(r -> r.n==2000, rez), :name)\n    p2 = plot(; xlabel = \"Nomber of covariates (m)\",\n                ylabel = \"L2Dist to $ref's β\",\n                yscale=:log10,\n                xscale= :log10,\n                title = \"n=2000, varying m\",\n                legend = :bottomright,\n                lw = 1);\n    for g in group2\n        plot!(p2, g.m, g.error, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n    end\n    p = plot(p1,p2, size=(1200,600), plot_title=\"β-correctness w.r.t. $ref's version.\")\n    return p\nend\n\n#beta_correctness_graphs(df)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"We will compare the diffferent models' coefficents values with the \"right\" beta value that we obtained while simulating our data.","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"function beta_wrt_truth(df)\n    group1 = groupby(filter(r -> r.m==10, df), :name)\n    p1 = plot(; xlabel = \"Number of observations (n)\",\n                ylabel = \"L2dist to the truth\",\n                yscale=:log10,\n                xscale= :log10,\n                title = \"m=20, varying n\",\n                legend = :bottomright,\n                lw = 1,\n                plot_title=\"β-correctness w.r.t. the truth.\");\n    for g in group1\n        plot!(p1, g.n, g.diff_to_truth, label = g.name[1] , color = design[g.name[1]][2], marker = :circle, markersize = 3)  \n    end\n\n    return p1\nend   \n\nbeta_wrt_truth(df)","category":"page"},{"location":"semiparametric/cox/","page":"Cox","title":"Cox","text":"D. R. Cox. Regression models and life-tables. Journal of the Royal Statistical Society: Series B (Methodological) 34, 187–202 (1972).\n\n\n\n","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SurvivalModels.jl package, part of the JuliaSurv ecosystem, provides the necessary tools to perform estimation and analysis of survival data. In contains three categories of models: Non-parametric ones, semi-parametric ones, and fully parametric models. It also contains tests of hypothesis and other features:","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Non-parametric modelling: \nKaplan-Meier\nLog-rank tests, including stratified versions \nSemi-Parametric modelling: \nCox\nParametric modelling: \nGeneral Hazard models","category":"page"},{"location":"","page":"Home","title":"Home","text":"In particular, our Cox implementation is fast, compared to off-the-shelf Julia and R equivalents. Check it out ! ","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you find the slightest bug or want to discuss addition of other methods, or simply chat, do not hesitate to open an issue on the repository. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is available in Julia's General registry, and thus can be installed through the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add SurvivalModels","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
